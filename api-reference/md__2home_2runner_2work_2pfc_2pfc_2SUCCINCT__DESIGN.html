<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PFC - Prefix-Free Codecs: Succinct Data Structures Design Document</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PFC - Prefix-Free Codecs<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">A header-only C++20 library for zero-copy, prefix-free data representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2pfc_2pfc_2SUCCINCT__DESIGN.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Succinct Data Structures Design Document</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md77"></a> </p>
<h1><a class="anchor" id="autotoc_md78"></a>
Executive Summary</h1>
<p>This document outlines the architecture for adding succinct data structures to the PFC library, leveraging the library's unique competitive advantage: <b>wire format = in-memory format</b> (zero-copy).</p>
<h1><a class="anchor" id="autotoc_md79"></a>
Quick Wins - Phase 1 (COMPLETED)</h1>
<h2><a class="anchor" id="autotoc_md80"></a>
Three New Universal Codes</h2>
<h3><a class="anchor" id="autotoc_md81"></a>
1. VByte (Variable Byte / Varint) ✓</h3>
<ul>
<li><b>Status</b>: Implemented and tested</li>
<li><b>Use Case</b>: Industry standard, Protocol Buffers compatible</li>
<li><b>Performance</b>: Cache-friendly, SIMD-ready</li>
<li><b>Encoding</b>: 7 data bits + 1 continuation bit per byte</li>
<li><b>Advantages</b>:<ul>
<li>Fast encoding/decoding</li>
<li>Byte-aligned for efficient processing</li>
<li>Widely used in practice (Lucene, Protocol Buffers)</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Example usage</span></div>
<div class="line">uint8_t buffer[100];</div>
<div class="line">BitWriter writer(buffer);</div>
<div class="line">codecs::VByte::encode(1000000u, writer);</div>
<div class="line"> </div>
<div class="line">BitReader reader(buffer, 100);</div>
<div class="line">uint32_t value = codecs::VByte::decode&lt;uint32_t&gt;(reader);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md82"></a>
2. Exponential-Golomb (Parameterized Family) ✓</h3>
<ul>
<li><b>Status</b>: Implemented and tested</li>
<li><b>Use Case</b>: Video coding standard (H.264, HEVC)</li>
<li><b>Performance</b>: Tunable for different distributions</li>
<li><b>Orders</b>:<ul>
<li>Order 0 = Elias Gamma</li>
<li>Higher orders = flatter distributions</li>
</ul>
</li>
<li><b>Advantages</b>:<ul>
<li>Flexible parameterization</li>
<li>Well-studied theoretical properties</li>
<li>Hardware-friendly in video codecs</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Order 0 (same as Elias Gamma)</span></div>
<div class="line">codecs::ExpGolomb&lt;0&gt;::encode(value, sink);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Order 1 (better for uniform distributions)</span></div>
<div class="line">codecs::ExpGolomb&lt;1&gt;::encode(value, sink);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convenience aliases</span></div>
<div class="line"><span class="keyword">using </span>ExpGolomb0 = ExpGolomb&lt;0&gt;;</div>
<div class="line"><span class="keyword">using </span>ExpGolomb1 = ExpGolomb&lt;1&gt;;</div>
<div class="line"><span class="keyword">using </span>ExpGolomb2 = ExpGolomb&lt;2&gt;;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md83"></a>
3. Elias Omega ✓</h3>
<ul>
<li><b>Status</b>: Implemented and tested</li>
<li><b>Use Case</b>: Large integers (better than Delta)</li>
<li><b>Performance</b>: Recursive length encoding</li>
<li><b>Advantages</b>:<ul>
<li>More efficient than Delta for large values</li>
<li>Theoretically optimal within log* factor</li>
<li>Completes the Elias family</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">uint8_t buffer[100];</div>
<div class="line">BitWriter writer(buffer);</div>
<div class="line">codecs::EliasOmega::encode(1000000u, writer);</div>
<div class="line"> </div>
<div class="line">BitReader reader(buffer, 100);</div>
<div class="line">uint32_t value = codecs::EliasOmega::decode&lt;uint32_t&gt;(reader);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md84"></a>
Test Results</h2>
<ul>
<li><b>All tests passing</b>: 2000 assertions across 9 test cases</li>
<li><b>Coverage</b>: Small values, large values, powers of 2, random data</li>
<li><b>Signed variants</b>: SignedVByte, SignedOmega included</li>
<li><b>Comparative tests</b>: Efficiency comparisons between codecs</li>
</ul>
<h1><a class="anchor" id="autotoc_md85"></a>
Succinct Structures - Phase 2 Foundation</h1>
<h2><a class="anchor" id="autotoc_md86"></a>
1. Succinct Bit Vector with Rank/Select</h2>
<p><b>Status</b>: API designed, implementation in progress</p>
<h3><a class="anchor" id="autotoc_md87"></a>
Design Principles</h3>
<ol type="1">
<li><b>Space</b>: n + o(n) bits total</li>
<li><b>Operations</b>: O(1) rank, O(log n) select</li>
<li><b>Zero-Copy</b>: Wire format = in-memory format</li>
<li><b>Composable</b>: Built on PackedValue concept</li>
</ol>
<h3><a class="anchor" id="autotoc_md88"></a>
Architecture</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>SuccinctBitVector {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;uint64_t&gt; bits_;           <span class="comment">// Bit data</span></div>
<div class="line">    <span class="keywordtype">size_t</span> num_bits_;                      <span class="comment">// Number of bits</span></div>
<div class="line">    BlockRankSupport rank_support_;        <span class="comment">// Rank/select metadata</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Construction</span></div>
<div class="line">    SuccinctBitVector(<span class="keywordtype">size_t</span> num_bits, <span class="keywordtype">bool</span> initial_value = <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Build rank support (call after modifications)</span></div>
<div class="line">    <span class="keywordtype">void</span> build_rank_support();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bit access</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator[](<span class="keywordtype">size_t</span> pos) <span class="keyword">const</span>;     <span class="comment">// O(1) read</span></div>
<div class="line">    <span class="keywordtype">void</span> set(<span class="keywordtype">size_t</span> pos, <span class="keywordtype">bool</span> value = <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordtype">void</span> reset(<span class="keywordtype">size_t</span> pos);</div>
<div class="line">    <span class="keywordtype">void</span> flip(<span class="keywordtype">size_t</span> pos);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Rank/Select operations</span></div>
<div class="line">    <span class="keywordtype">size_t</span> rank(<span class="keywordtype">size_t</span> pos) <span class="keyword">const</span>;         <span class="comment">// O(1)</span></div>
<div class="line">    <span class="keywordtype">size_t</span> select(<span class="keywordtype">size_t</span> k) <span class="keyword">const</span>;         <span class="comment">// O(log n)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Zero-copy serialization</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Sink&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> encode(<span class="keyword">const</span> SuccinctBitVector&amp; bv, Sink&amp; sink);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Source&gt;</div>
<div class="line">    <span class="keyword">static</span> SuccinctBitVector decode(Source&amp; source);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md89"></a>
Block-Based Rank Support</h3>
<div class="fragment"><div class="line">Structure:</div>
<div class="line">┌─────────────────────────────────────────────────────┐</div>
<div class="line">│ Superblock (65536 bits = 8KB)                       │</div>
<div class="line">│  ┌──────────────┬──────────────┬──────────────┐    │</div>
<div class="line">│  │ Block (512b) │ Block (512b) │ Block (512b) │... │</div>
<div class="line">│  └──────────────┴──────────────┴──────────────┘    │</div>
<div class="line">└─────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Metadata:</div>
<div class="line">- Superblocks: Absolute rank every 65536 bits (32-bit)</div>
<div class="line">- Blocks: Relative rank within superblock (16-bit)</div>
<div class="line">- Space overhead: n/512 + n/65536 = 0.196% + 0.003% ≈ 0.2%</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md90"></a>
Zero-Copy Wire Format</h3>
<div class="fragment"><div class="line">Encoding:</div>
<div class="line">┌────────────┬──────────────┬───────────────────┐</div>
<div class="line">│ num_bits   │ bit_data     │ rank_support      │</div>
<div class="line">│ (Gamma)    │ (raw bits)   │ (blocks+metadata) │</div>
<div class="line">└────────────┴──────────────┴───────────────────┘</div>
<div class="line"> </div>
<div class="line">Key advantage: bit_data is directly memory-mappable!</div>
<div class="line">No parsing, no decoding - just point and use.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md91"></a>
Example Usage</h2>
<div class="fragment"><div class="line"><span class="comment">// Build a succinct bit vector</span></div>
<div class="line">SuccinctBitVector bv(1000);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 1000; i += 7) {</div>
<div class="line">    bv.set(i);  <span class="comment">// Set every 7th bit</span></div>
<div class="line">}</div>
<div class="line">bv.build_rank_support();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Query operations</span></div>
<div class="line"><span class="keywordtype">size_t</span> ones_before_100 = bv.rank(100);     <span class="comment">// Count 1s in [0, 100)</span></div>
<div class="line"><span class="keywordtype">size_t</span> tenth_one = bv.select(10);          <span class="comment">// Find 10th 1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Zero-copy serialization</span></div>
<div class="line">uint8_t buffer[10000];</div>
<div class="line">BitWriter writer(buffer);</div>
<div class="line">SuccinctBitVector::encode(bv, writer);</div>
<div class="line">writer.align();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Zero-copy deserialization (no parsing!)</span></div>
<div class="line">BitReader reader(buffer, 10000);</div>
<div class="line"><span class="keyword">auto</span> bv2 = SuccinctBitVector::decode(reader);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Works immediately - no build step needed</span></div>
<div class="line"><span class="keywordtype">size_t</span> rank_check = bv2.rank(100);</div>
<div class="line">assert(rank_check == ones_before_100);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md92"></a>
Phase 3: Advanced Succinct Structures</h1>
<h2><a class="anchor" id="autotoc_md93"></a>
2. Roaring Bitmaps</h2>
<p><b>Compressed integer sets with O(1) operations</b></p>
<h3><a class="anchor" id="autotoc_md94"></a>
Design Sketch</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>RoaringBitmap {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Three container types based on cardinality:</span></div>
<div class="line">    <span class="keyword">enum class</span> ContainerType : uint8_t {</div>
<div class="line">        Array,   <span class="comment">// Sorted uint16_t array (&lt; 4096 elements)</span></div>
<div class="line">        Bitmap,  <span class="comment">// 8KB bit vector (dense sets)</span></div>
<div class="line">        Run      <span class="comment">// Run-length encoded runs</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>Chunk {</div>
<div class="line">        uint16_t key;                      <span class="comment">// High 16 bits</span></div>
<div class="line">        ContainerType type;                <span class="comment">// Container type</span></div>
<div class="line">        PackedVector&lt;uint16_t&gt; data;       <span class="comment">// Low 16 bits</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    PackedVector&lt;Chunk&gt; chunks_;           <span class="comment">// Sorted by key</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// STL set-like interface</span></div>
<div class="line">    <span class="keywordtype">bool</span> contains(uint32_t x) <span class="keyword">const</span>;       <span class="comment">// O(log n + 1)</span></div>
<div class="line">    <span class="keywordtype">void</span> insert(uint32_t x);               <span class="comment">// O(log n + k)</span></div>
<div class="line">    <span class="keywordtype">void</span> remove(uint32_t x);               <span class="comment">// O(log n + k)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set operations (zero-copy where possible)</span></div>
<div class="line">    RoaringBitmap union_with(<span class="keyword">const</span> RoaringBitmap&amp; other) <span class="keyword">const</span>;</div>
<div class="line">    RoaringBitmap intersect_with(<span class="keyword">const</span> RoaringBitmap&amp; other) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Iteration</span></div>
<div class="line">    <span class="keyword">class </span>iterator {</div>
<div class="line">        <span class="comment">// Proxy iterator for zero-copy access</span></div>
<div class="line">        uint32_t operator*() <span class="keyword">const</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Zero-copy wire format</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Sink&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> encode(<span class="keyword">const</span> RoaringBitmap&amp; rb, Sink&amp; sink);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md95"></a>
Zero-Copy Advantage</h3>
<div class="fragment"><div class="line">Traditional Roaring:</div>
<div class="line">┌──────────┬──────────┬──────────┐</div>
<div class="line">│ Chunk 1  │ Chunk 2  │ Chunk 3  │</div>
<div class="line">└──────────┴──────────┴──────────┘</div>
<div class="line">         ↓</div>
<div class="line">    Parse each chunk type</div>
<div class="line">    Allocate containers</div>
<div class="line">    Copy data</div>
<div class="line"> </div>
<div class="line">PFC Roaring:</div>
<div class="line">┌──────────┬──────────┬──────────┐</div>
<div class="line">│ Chunk 1  │ Chunk 2  │ Chunk 3  │</div>
<div class="line">└──────────┴──────────┴──────────┘</div>
<div class="line">         ↓</div>
<div class="line">    Point directly to wire format</div>
<div class="line">    Zero parsing, zero allocation</div>
<div class="line">    Instant access</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md96"></a>
3. Interpolative Coding</h2>
<p><b>Optimal compression for sorted integers</b></p>
<div class="fragment"><div class="line"><span class="keyword">class </span>InterpolativeCoded {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    SuccinctBitVector bits_;               <span class="comment">// Encoded bit stream</span></div>
<div class="line">    <span class="keywordtype">size_t</span> universe_size_;                 <span class="comment">// Maximum value</span></div>
<div class="line">    <span class="keywordtype">size_t</span> num_elements_;                  <span class="comment">// Number of integers</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Recursive encoding helper</span></div>
<div class="line">    <span class="keywordtype">void</span> encode_range(<span class="keyword">const</span> std::vector&lt;uint32_t&gt;&amp; vals,</div>
<div class="line">                     <span class="keywordtype">size_t</span> low, <span class="keywordtype">size_t</span> high,</div>
<div class="line">                     uint32_t min_val, uint32_t max_val);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Construction</span></div>
<div class="line">    <span class="keyword">static</span> InterpolativeCoded from_sorted_array(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;uint32_t&gt;&amp; vals,</div>
<div class="line">        uint32_t universe_size</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// O(log n) access with binary interpolation search</span></div>
<div class="line">    uint32_t operator[](<span class="keywordtype">size_t</span> index) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Iteration</span></div>
<div class="line">    <span class="keyword">class </span>iterator {</div>
<div class="line">        uint32_t operator*() <span class="keyword">const</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Zero-copy wire format</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Sink&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> encode(<span class="keyword">const</span> InterpolativeCoded&amp; ic, Sink&amp; sink);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md97"></a>
Use Cases</h3>
<ul>
<li>Inverted indices (document IDs)</li>
<li>Sorted sensor readings</li>
<li>Timestamp sequences</li>
<li>Any monotonic sequence</li>
</ul>
<h2><a class="anchor" id="autotoc_md98"></a>
4. Wavelet Tree</h2>
<p><b>Powerful sequence structure with rank/select on arbitrary alphabets</b></p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Symbol = u<span class="keywordtype">int</span>8_t&gt;</div>
<div class="line"><span class="keyword">class </span>WaveletTree {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    SuccinctBitVector level_bits_;         <span class="comment">// All levels concatenated</span></div>
<div class="line">    std::vector&lt;size_t&gt; level_boundaries_; <span class="comment">// Start of each level</span></div>
<div class="line">    <span class="keywordtype">size_t</span> alphabet_size_;                 <span class="comment">// Size of alphabet</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Construction</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">    <span class="keyword">static</span> WaveletTree from_sequence(Iterator begin, Iterator end);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// O(log σ) rank/select for any symbol</span></div>
<div class="line">    <span class="keywordtype">size_t</span> rank(Symbol s, <span class="keywordtype">size_t</span> pos) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> select(Symbol s, <span class="keywordtype">size_t</span> k) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// O(log σ) access</span></div>
<div class="line">    Symbol operator[](<span class="keywordtype">size_t</span> pos) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Advanced queries</span></div>
<div class="line">    std::vector&lt;Symbol&gt; range(<span class="keywordtype">size_t</span> start, <span class="keywordtype">size_t</span> end) <span class="keyword">const</span>;</div>
<div class="line">    std::pair&lt;Symbol, size_t&gt; most_frequent(<span class="keywordtype">size_t</span> start, <span class="keywordtype">size_t</span> end) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Zero-copy wire format</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Sink&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> encode(<span class="keyword">const</span> WaveletTree&amp; wt, Sink&amp; sink);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md99"></a>
Applications</h3>
<ul>
<li>Text indexing with rank/select on any character</li>
<li>Range queries on sequences</li>
<li>Top-k queries</li>
<li>Substring matching</li>
</ul>
<h2><a class="anchor" id="autotoc_md100"></a>
5. Packed Graphs</h2>
<p><b>Succinct graph representations</b></p>
<div class="fragment"><div class="line"><span class="comment">// Compressed Sparse Row (CSR) format</span></div>
<div class="line"><span class="keyword">class </span>PackedGraph {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    PackedVector&lt;uint32_t, codecs::EliasDelta&gt; offsets_;</div>
<div class="line">    PackedVector&lt;uint32_t, codecs::VByte&gt; edges_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Graph construction</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> EdgeList&gt;</div>
<div class="line">    <span class="keyword">static</span> PackedGraph from_edges(<span class="keyword">const</span> EdgeList&amp; edges, <span class="keywordtype">size_t</span> num_vertices);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph queries</span></div>
<div class="line">    <span class="keywordtype">size_t</span> num_vertices() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> num_edges() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Neighbor access with proxy iterator</span></div>
<div class="line">    <span class="keyword">struct </span>Neighbors {</div>
<div class="line">        <span class="keyword">class </span>iterator {</div>
<div class="line">            uint32_t operator*() <span class="keyword">const</span>;</div>
<div class="line">        };</div>
<div class="line">        iterator begin() <span class="keyword">const</span>;</div>
<div class="line">        iterator end() <span class="keyword">const</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Neighbors neighbors(uint32_t v) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph algorithms (work with standard algorithms via iterators)</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Visitor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> for_each_neighbor(uint32_t v, Visitor&amp;&amp; vis) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Zero-copy wire format</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Sink&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> encode(<span class="keyword">const</span> PackedGraph&amp; g, Sink&amp; sink);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md101"></a>
Zero-Copy Advantage</h3>
<div class="fragment"><div class="line">Traditional CSR:</div>
<div class="line">┌─────────────┬──────────────────────┐</div>
<div class="line">│ Offsets     │ Edges                │</div>
<div class="line">│ [0,3,7,...]│ [1,5,9,2,3,8,...]   │</div>
<div class="line">└─────────────┴──────────────────────┘</div>
<div class="line">         ↓</div>
<div class="line">    Fixed 32-bit or 64-bit integers</div>
<div class="line">    Wastes space for small values</div>
<div class="line"> </div>
<div class="line">PFC PackedGraph:</div>
<div class="line">┌─────────────┬──────────────────────┐</div>
<div class="line">│ Offsets     │ Edges                │</div>
<div class="line">│ (Delta)     │ (VByte)              │</div>
<div class="line">└─────────────┴──────────────────────┘</div>
<div class="line">         ↓</div>
<div class="line">    Variable-length encoding</div>
<div class="line">    Wire format = in-memory format</div>
<div class="line">    No decompression step</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md102"></a>
6. Rank-Select Dictionary</h2>
<p><b>Space-efficient sparse bit vectors</b></p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RankSelectDictionary {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    PackedVector&lt;uint32_t, codecs::EliasDelta&gt; ones_;</div>
<div class="line">    <span class="keywordtype">size_t</span> universe_size_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Construction</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">    <span class="keyword">static</span> RankSelectDictionary from_positions(</div>
<div class="line">        Iterator begin, Iterator end,</div>
<div class="line">        <span class="keywordtype">size_t</span> universe_size</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// O(log n) rank via binary search</span></div>
<div class="line">    <span class="keywordtype">size_t</span> rank(<span class="keywordtype">size_t</span> pos) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// O(1) select via direct access</span></div>
<div class="line">    <span class="keywordtype">size_t</span> select(<span class="keywordtype">size_t</span> k)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ones_[k]; }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Size queries</span></div>
<div class="line">    <span class="keywordtype">size_t</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ones_.size(); }</div>
<div class="line">    <span class="keywordtype">size_t</span> universe_size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> universe_size_; }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Zero-copy wire format</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Sink&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> encode(<span class="keyword">const</span> RankSelectDictionary&amp; rsd, Sink&amp; sink);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md103"></a>
Use Case</h3>
<p>When the bit vector is very sparse (&lt; 1% density), this representation is more space-efficient than full rank/select structures.</p>
<h1><a class="anchor" id="autotoc_md104"></a>
Design Principles</h1>
<h2><a class="anchor" id="autotoc_md105"></a>
1. Zero-Copy First</h2>
<p><b>THE COMPETITIVE ADVANTAGE</b></p>
<div class="fragment"><div class="line">Traditional Approach:</div>
<div class="line">┌──────────┐    Parse    ┌──────────┐    Build    ┌──────────┐</div>
<div class="line">│   Wire   │──────────→ │  Memory  │──────────→ │  Query   │</div>
<div class="line">│  Format  │             │  Format  │             │  Ready   │</div>
<div class="line">└──────────┘             └──────────┘             └──────────┘</div>
<div class="line">    ↓                         ↓                        ↓</div>
<div class="line">  Compact               Expanded               Fast queries</div>
<div class="line">                        + Metadata</div>
<div class="line"> </div>
<div class="line">PFC Approach:</div>
<div class="line">┌──────────┐    mmap     ┌──────────┐</div>
<div class="line">│   Wire   │──────────→ │  Query   │</div>
<div class="line">│  Format  │             │  Ready   │</div>
<div class="line">└──────────┘             └──────────┘</div>
<div class="line">    ↓                        ↓</div>
<div class="line">  Compact               Fast queries</div>
<div class="line">  (SAME REPRESENTATION)</div>
</div><!-- fragment --><p>Key advantages:</p><ul>
<li><b>Instant loading</b>: No parsing, no allocation</li>
<li><b>Memory efficiency</b>: One copy, not two</li>
<li><b>Cache efficiency</b>: Data is already organized for access</li>
<li><b>Persistence</b>: Write memory directly to disk</li>
</ul>
<h2><a class="anchor" id="autotoc_md106"></a>
2. Composability</h2>
<p>Build complex structures from simple ones:</p>
<div class="fragment"><div class="line"><span class="comment">// Compose codecs</span></div>
<div class="line"><span class="keyword">using </span>GraphCodec = Adaptive&lt;VByte, EliasDelta&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compose packed values</span></div>
<div class="line"><span class="keyword">using </span>PackedBitVec = Packed&lt;SuccinctBitVector, SuccinctBitVector&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Build collections</span></div>
<div class="line">PackedVector&lt;PackedBitVec&gt; bitvector_collection;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nest structures</span></div>
<div class="line"><span class="keyword">using </span>WaveletForest = PackedVector&lt;WaveletTree&lt;uint8_t&gt;&gt;;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md107"></a>
3. STL-Adjacent</h2>
<p>Familiar interfaces, standard patterns:</p>
<div class="fragment"><div class="line"><span class="comment">// STL vector-like</span></div>
<div class="line"><span class="keyword">auto</span> bv = SuccinctBitVector(1000);</div>
<div class="line"><span class="keywordtype">size_t</span> n = bv.size();</div>
<div class="line"><span class="keywordtype">bool</span> bit = bv[42];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// STL set-like</span></div>
<div class="line"><span class="keyword">auto</span> rb = RoaringBitmap();</div>
<div class="line">rb.insert(42);</div>
<div class="line"><span class="keywordtype">bool</span> has = rb.contains(42);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// STL algorithms work</span></div>
<div class="line"><span class="keyword">auto</span> graph = PackedGraph::from_edges(edges, num_vertices);</div>
<div class="line"><span class="keyword">auto</span> neighbors = graph.neighbors(v);</div>
<div class="line"><span class="keyword">auto</span> count = std::distance(neighbors.begin(), neighbors.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Range support</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> neighbor : graph.neighbors(v)) {</div>
<div class="line">    process(neighbor);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md108"></a>
4. Performance First</h2>
<p>Cache-friendly, SIMD-ready, theoretically optimal:</p>
<div class="fragment"><div class="line"><span class="comment">// Block sizes align with cache lines</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> BLOCK_SIZE = 512;  <span class="comment">// 64 bytes</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use hardware instructions</span></div>
<div class="line"><span class="keywordtype">size_t</span> popcount = __builtin_popcountll(word);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Avoid branching in hot loops</span></div>
<div class="line">result += (condition ? value : 0);  <span class="comment">// NOT: if (condition) result += value;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Batch operations</span></div>
<div class="line"><span class="keywordtype">void</span> encode_batch(<span class="keyword">const</span> uint32_t* values, <span class="keywordtype">size_t</span> count, Sink&amp; sink);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md109"></a>
5. Immutable by Default</h2>
<p>Clear separation between construction and querying:</p>
<div class="fragment"><div class="line"><span class="comment">// Construction phase (mutable)</span></div>
<div class="line">SuccinctBitVector::Builder builder(1000);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 1000; i += 7) {</div>
<div class="line">    builder.set(i);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> bv = builder.build();  <span class="comment">// Build rank support</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Query phase (immutable, thread-safe)</span></div>
<div class="line"><span class="keywordtype">size_t</span> rank = bv.rank(100);</div>
<div class="line"><span class="keywordtype">size_t</span> select = bv.select(10);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Serialization (from immutable structure)</span></div>
<div class="line">uint8_t buffer[10000];</div>
<div class="line">BitWriter writer(buffer);</div>
<div class="line">SuccinctBitVector::encode(bv, writer);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md110"></a>
Integration with Existing PFC</h1>
<h2><a class="anchor" id="autotoc_md111"></a>
Header Organization</h2>
<div class="fragment"><div class="line">include/pfc/</div>
<div class="line">├── core.hpp              # Bit I/O, concepts</div>
<div class="line">├── codecs.hpp            # Universal codes (now with VByte, ExpGolomb, Omega)</div>
<div class="line">├── packed.hpp            # Packed value types</div>
<div class="line">├── succinct.hpp          # Succinct bit vector (NEW)</div>
<div class="line">├── succinct_roaring.hpp  # Roaring bitmaps (FUTURE)</div>
<div class="line">├── succinct_wavelet.hpp  # Wavelet trees (FUTURE)</div>
<div class="line">├── succinct_graph.hpp    # Packed graphs (FUTURE)</div>
<div class="line">└── pfc.hpp              # Main header</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md112"></a>
Namespace Structure</h2>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacepfc.html">pfc</a> {</div>
<div class="line">    <span class="comment">// Core functionality</span></div>
<div class="line">    <span class="keyword">class </span>BitWriter;</div>
<div class="line">    <span class="keyword">class </span>BitReader;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>codecs {</div>
<div class="line">        <span class="keyword">struct </span>VByte;           <span class="comment">// NEW</span></div>
<div class="line">        <span class="keyword">struct </span>ExpGolomb;       <span class="comment">// NEW</span></div>
<div class="line">        <span class="keyword">struct </span>EliasOmega;      <span class="comment">// NEW</span></div>
<div class="line">        <span class="keyword">struct </span>EliasGamma;</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>succinct {        <span class="comment">// NEW NAMESPACE</span></div>
<div class="line">        <span class="keyword">class </span>SuccinctBitVector;</div>
<div class="line">        <span class="keyword">class </span>RoaringBitmap;     <span class="comment">// FUTURE</span></div>
<div class="line">        <span class="keyword">class </span>WaveletTree;       <span class="comment">// FUTURE</span></div>
<div class="line">        <span class="keyword">class </span>PackedGraph;       <span class="comment">// FUTURE</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacepfc_html"><div class="ttname"><a href="namespacepfc.html">pfc</a></div><div class="ttdef"><b>Definition</b> <a href="algebraic_8hpp_source.html#l00011">algebraic.hpp:11</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md113"></a>
PackedValue Integration</h2>
<p>All succinct structures implement the PackedValue concept:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;</div>
<div class="line"><span class="keyword">concept </span>PackedValue = <span class="keyword">requires</span>(<span class="keyword">const</span> P&amp; p, BitWriter&amp; w, BitReader&amp; r) {</div>
<div class="line">    <span class="keyword">typename</span> P::value_type;</div>
<div class="line">    { P::encode(p, w) } -&gt; std::same_as&lt;void&gt;;</div>
<div class="line">    { P::decode(r) } -&gt; std::same_as&lt;P&gt;;</div>
<div class="line">    { p.value() } -&gt; std::convertible_to&lt;typename P::value_type&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SuccinctBitVector is a PackedValue</span></div>
<div class="line"><span class="keyword">static_assert</span>(PackedValue&lt;SuccinctBitVector&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Can be used in PackedVector</span></div>
<div class="line">PackedVector&lt;SuccinctBitVector&gt; bitvector_collection;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Can be used in PackedOptional</span></div>
<div class="line">PackedOptional&lt;SuccinctBitVector&gt; maybe_bitvec;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md114"></a>
Performance Considerations</h1>
<h2><a class="anchor" id="autotoc_md115"></a>
Space Overhead</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Structure   </th><th class="markdownTableHeadNone">Space   </th><th class="markdownTableHeadNone">Overhead   </th><th class="markdownTableHeadNone">Comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SuccinctBitVector   </td><td class="markdownTableBodyNone">n + 0.2n   </td><td class="markdownTableBodyNone">0.2%   </td><td class="markdownTableBodyNone">Block-based rank    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RoaringBitmap   </td><td class="markdownTableBodyNone">Variable   </td><td class="markdownTableBodyNone">0-50%   </td><td class="markdownTableBodyNone">Depends on cardinality    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">InterpolativeCoded   </td><td class="markdownTableBodyNone">~log₂(U choose N)   </td><td class="markdownTableBodyNone">Optimal   </td><td class="markdownTableBodyNone">Information-theoretic    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WaveletTree   </td><td class="markdownTableBodyNone">n log σ + o(n log σ)   </td><td class="markdownTableBodyNone">~5%   </td><td class="markdownTableBodyNone">Includes rank structures    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PackedGraph (CSR)   </td><td class="markdownTableBodyNone">~7 bits/edge   </td><td class="markdownTableBodyNone">40-50%   </td><td class="markdownTableBodyNone">vs 64-bit pointers   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md116"></a>
Time Complexity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">SuccinctBitVector   </th><th class="markdownTableHeadNone">RoaringBitmap   </th><th class="markdownTableHeadNone">WaveletTree   </th><th class="markdownTableHeadNone">PackedGraph    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Access   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">O(log chunks)   </td><td class="markdownTableBodyNone">O(log σ)   </td><td class="markdownTableBodyNone">O(log V + degree)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rank   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">O(log chunks)   </td><td class="markdownTableBodyNone">O(log σ)   </td><td class="markdownTableBodyNone">N/A    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Select   </td><td class="markdownTableBodyNone">O(log n)   </td><td class="markdownTableBodyNone">O(log chunks)   </td><td class="markdownTableBodyNone">O(log σ log n)   </td><td class="markdownTableBodyNone">N/A    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Insert   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(log chunks + k)   </td><td class="markdownTableBodyNone">O(n log σ)   </td><td class="markdownTableBodyNone">O(n)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Union   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n + m)   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md117"></a>
Testing Strategy</h1>
<h2><a class="anchor" id="autotoc_md118"></a>
Unit Tests</h2>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;SuccinctBitVector rank operations&quot;</span>, <span class="stringliteral">&quot;[succinct]&quot;</span>) {</div>
<div class="line">    SuccinctBitVector bv(1000);</div>
<div class="line"> </div>
<div class="line">    SECTION(<span class="stringliteral">&quot;Empty bit vector&quot;</span>) {</div>
<div class="line">        bv.build_rank_support();</div>
<div class="line">        REQUIRE(bv.rank(500) == 0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SECTION(<span class="stringliteral">&quot;Single bit set&quot;</span>) {</div>
<div class="line">        bv.set(100);</div>
<div class="line">        bv.build_rank_support();</div>
<div class="line">        REQUIRE(bv.rank(100) == 0);</div>
<div class="line">        REQUIRE(bv.rank(101) == 1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SECTION(<span class="stringliteral">&quot;Random bits&quot;</span>) {</div>
<div class="line">        std::mt19937 gen(42);</div>
<div class="line">        std::uniform_int_distribution&lt;size_t&gt; dist(0, 999);</div>
<div class="line"> </div>
<div class="line">        std::set&lt;size_t&gt; set_positions;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i) {</div>
<div class="line">            <span class="keywordtype">size_t</span> pos = dist(gen);</div>
<div class="line">            bv.set(pos);</div>
<div class="line">            set_positions.insert(pos);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        bv.build_rank_support();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">size_t</span> expected_rank = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (set_positions.count(i)) ++expected_rank;</div>
<div class="line">            REQUIRE(bv.rank(i + 1) == expected_rank);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Zero-copy round trip&quot;</span>, <span class="stringliteral">&quot;[succinct]&quot;</span>) {</div>
<div class="line">    SuccinctBitVector bv(100);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 100; i += 3) {</div>
<div class="line">        bv.set(i);</div>
<div class="line">    }</div>
<div class="line">    bv.build_rank_support();</div>
<div class="line"> </div>
<div class="line">    uint8_t buffer[1000];</div>
<div class="line">    BitWriter writer(buffer);</div>
<div class="line">    SuccinctBitVector::encode(bv, writer);</div>
<div class="line">    writer.align();</div>
<div class="line"> </div>
<div class="line">    BitReader reader(buffer, 1000);</div>
<div class="line">    <span class="keyword">auto</span> bv2 = SuccinctBitVector::decode(reader);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Verify identical behavior</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt;= 100; ++i) {</div>
<div class="line">        REQUIRE(bv.rank(i) == bv2.rank(i));</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md119"></a>
Benchmark Tests</h2>
<div class="fragment"><div class="line">BENCHMARK(<span class="stringliteral">&quot;SuccinctBitVector rank&quot;</span>) {</div>
<div class="line">    SuccinctBitVector bv(1000000);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 1000000; i += 7) {</div>
<div class="line">        bv.set(i);</div>
<div class="line">    }</div>
<div class="line">    bv.build_rank_support();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> bv.rank(500000);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">BENCHMARK(<span class="stringliteral">&quot;VByte encode/decode&quot;</span>) {</div>
<div class="line">    uint8_t buffer[100];</div>
<div class="line">    BitWriter writer(buffer);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; 1000; ++i) {</div>
<div class="line">        codecs::VByte::encode(i, writer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    BitReader reader(buffer, 100);</div>
<div class="line">    uint32_t sum = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; 1000; ++i) {</div>
<div class="line">        sum += codecs::VByte::decode&lt;uint32_t&gt;(reader);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> sum;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md120"></a>
Roadmap</h1>
<h2><a class="anchor" id="autotoc_md121"></a>
Phase 1: Quick Wins ✓ COMPLETED</h2>
<ul>
<li>[x] VByte codec</li>
<li>[x] Exponential-Golomb family</li>
<li>[x] Elias Omega</li>
<li>[x] Comprehensive tests</li>
<li>[x] Documentation</li>
</ul>
<h2><a class="anchor" id="autotoc_md122"></a>
Phase 2: Foundation (IN PROGRESS)</h2>
<ul>
<li>[x] Succinct bit vector API design</li>
<li>[x] Block-based rank support</li>
<li>[ ] Complete implementation</li>
<li>[ ] Comprehensive testing</li>
<li>[ ] Performance benchmarks</li>
</ul>
<h2><a class="anchor" id="autotoc_md123"></a>
Phase 3: Core Structures (NEXT)</h2>
<ul>
<li>[ ] Roaring bitmaps</li>
<li>[ ] Interpolative coding</li>
<li>[ ] Wavelet trees</li>
<li>[ ] Packed graphs</li>
</ul>
<h2><a class="anchor" id="autotoc_md124"></a>
Phase 4: Advanced Features</h2>
<ul>
<li>[ ] Compressed suffix arrays</li>
<li>[ ] FM-index</li>
<li>[ ] Compressed text indices</li>
<li>[ ] Spatial data structures</li>
</ul>
<h2><a class="anchor" id="autotoc_md125"></a>
Phase 5: Optimization</h2>
<ul>
<li>[ ] SIMD acceleration</li>
<li>[ ] Multi-threaded construction</li>
<li>[ ] GPU support</li>
<li>[ ] Memory mapping utilities</li>
</ul>
<h1><a class="anchor" id="autotoc_md126"></a>
References</h1>
<h2><a class="anchor" id="autotoc_md127"></a>
Papers</h2>
<ol type="1">
<li>Jacobson, G. (1989). "Space-efficient static trees and graphs"</li>
<li>Clark, D. (1996). "Compact Pat Trees"</li>
<li>Navarro, G. &amp; Mäkinen, V. (2007). "Compressed full-text indexes"</li>
<li>Chambi, S. et al. (2016). "Better bitmap performance with Roaring bitmaps"</li>
<li>Moffat, A. &amp; Stuiver, L. (2000). "Binary interpolative coding"</li>
</ol>
<h2><a class="anchor" id="autotoc_md128"></a>
Libraries (for inspiration, not copying)</h2>
<ul>
<li>SDSL-lite: Succinct Data Structure Library</li>
<li>Roaring: Roaring bitmaps reference implementation</li>
<li>Elias-Fano: Various implementations</li>
<li>Wavelet trees: Multiple implementations</li>
</ul>
<h2><a class="anchor" id="autotoc_md129"></a>
Standards</h2>
<ul>
<li>Protocol Buffers varint encoding (VByte)</li>
<li>H.264 video standard (Exp-Golomb)</li>
</ul>
<h1><a class="anchor" id="autotoc_md130"></a>
Conclusion</h1>
<p>The PFC succinct structures design leverages the library's unique zero-copy architecture to provide:</p>
<ol type="1">
<li><b>Instant loading</b>: No parsing step</li>
<li><b>Memory efficiency</b>: One representation for storage and queries</li>
<li><b>Performance</b>: Cache-friendly, theoretically optimal algorithms</li>
<li><b>Composability</b>: Build complex structures from simple primitives</li>
<li><b>Familiarity</b>: STL-adjacent interfaces</li>
</ol>
<p>The three new codecs (VByte, ExpGolomb, EliasOmega) are implemented and tested, providing a solid foundation for the succinct structures to come.</p>
<p><b>Next Steps</b>:</p><ol type="1">
<li>Complete SuccinctBitVector implementation</li>
<li>Add comprehensive tests and benchmarks</li>
<li>Begin Roaring bitmap implementation</li>
<li>Document usage patterns and best practices </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Nov 25 2025 22:31:34 for PFC - Prefix-Free Codecs by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
