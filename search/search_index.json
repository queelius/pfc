{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PFC - Prefix-Free Codecs","text":"<p>Welcome to the documentation for PFC, a header-only C++20 library for zero-copy, prefix-free data representations with full algebraic type support and STL integration.</p>"},{"location":"#overview","title":"Overview","text":"<p>PFC implements a comprehensive suite of prefix-free codecs and data structures that maintain a zero-copy invariant: the in-memory representation is identical to the wire format. This eliminates marshaling overhead while providing powerful compression and type composition capabilities.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Zero-Copy Invariant: In-memory bytes = wire bytes (no marshaling)</li> <li>Prefix-Free Codes: Self-delimiting, streaming-friendly encodings</li> <li>Algebraic Type System: Sum types, product types, recursive types</li> <li>STL Integration: Works seamlessly with standard algorithms</li> <li>Rich Codec Library: Universal codes, floating point, rationals, and more</li> <li>Compile-Time Composition: Modern C++ concepts and templates</li> <li>Mathematical Rigor: Based on Stepanov's generic programming principles</li> </ul>"},{"location":"#test-coverage","title":"Test Coverage","text":"<p>The library is thoroughly tested with 689 passing assertions across 31 test cases:</p> <ul> <li>Core Tests (419 assertions): Codecs, packed values, basic algorithms</li> <li>Advanced Tests (116 assertions): Algebraic types, STL integration, coordinates</li> <li>Production Tests (142 assertions): Huffman, LZ77, error handling, allocators</li> <li>CRC Tests (12 assertions): CRC8, CRC16, CRC32 checksums</li> <li>Stream/Arithmetic Tests: Stream I/O and arithmetic coding</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include &lt;pfc/pfc.hpp&gt;\nusing namespace pfc;\n\n// Simple compression\nstd::vector&lt;uint32_t&gt; data = {1, 2, 3, 5, 8, 13, 21};\nauto compressed = compress&lt;EliasGamma&gt;(data);\nauto decompressed = decompress&lt;EliasGamma, uint32_t&gt;(compressed);\n\n// Algebraic types\nusing OptionalInt = PackedOptional&lt;Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;&gt;;\nOptionalInt some_value = 42;\nOptionalInt no_value = std::nullopt;\n\n// STL integration\nPackedContainer&lt;uint32_t, EliasGamma&gt; container;\ncontainer.push_back(100);\ncontainer.push_back(200);\nstd::sort(container.begin(), container.end());\n</code></pre>"},{"location":"#why-pfc","title":"Why PFC?","text":""},{"location":"#zero-copy-performance","title":"Zero-Copy Performance","text":"<p>Traditional serialization libraries copy data between in-memory and wire representations. PFC eliminates this overhead by making them identical:</p> <pre><code>// Traditional approach (2 copies)\nstd::vector&lt;int&gt; data = {1, 2, 3};\nauto serialized = serialize(data);  // Copy 1\nsend_over_network(serialized);\nauto received = receive_from_network();\nauto deserialized = deserialize&lt;std::vector&lt;int&gt;&gt;(received);  // Copy 2\n\n// PFC approach (0 copies)\nPackedVector&lt;PackedInt&gt; data = {1, 2, 3};\nsend_over_network(data.data(), data.byte_size());  // Direct memory access\nPackedVector&lt;PackedInt&gt; received(buffer, buffer_size);  // Zero-copy view\n</code></pre>"},{"location":"#prefix-free-advantage","title":"Prefix-Free Advantage","text":"<p>Prefix-free codes are self-delimiting, enabling:</p> <ul> <li>Streaming processing without lookahead</li> <li>Concatenation without separators</li> <li>Variable-length encoding with guaranteed decoding</li> </ul>"},{"location":"#type-safety","title":"Type Safety","text":"<p>Strong typing prevents common serialization errors:</p> <pre><code>// Type-safe tagged unions\nusing Response = PackedVariant&lt;\n    Packed&lt;Success, SuccessCodec&gt;,\n    Packed&lt;Error, ErrorCodec&gt;\n&gt;;\n\n// Compiler enforces exhaustive pattern matching\nauto result = response.visit(overloaded{\n    [](const Success&amp; s) { return process(s); },\n    [](const Error&amp; e) { return handle_error(e); }\n});\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>PFC is organized into focused modules:</p> <ul> <li>Core: Bit I/O primitives, concepts, fundamental abstractions</li> <li>Codecs: Universal integer codes (Elias, Fibonacci, Rice)</li> <li>Numeric: Floating point, rational, complex number codecs</li> <li>Packed: Value types and containers with zero-copy semantics</li> <li>Algebraic: Sum and product types for type composition</li> <li>STL Integration: Iterators, algorithms, and standard compatibility</li> <li>Compression: Huffman, LZ77, arithmetic coding</li> <li>Utilities: CRC checksums, stream I/O, error handling</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide: Get up and running</li> <li>Quick Start Tutorial: Learn the basics</li> <li>API Reference: Detailed documentation</li> <li>Examples: Real-world usage patterns</li> <li>Design Principles: Understand the philosophy</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>C++20 compliant compiler (GCC 10+, Clang 12+, MSVC 2019+)</li> <li>CMake 3.15+ (for building tests and examples)</li> <li>Header-only library, no external dependencies required</li> </ul>"},{"location":"#license","title":"License","text":"<p>PFC is released under the MIT License. See LICENSE for details.</p>"},{"location":"api/algebraic/","title":"Algebraic Types API","text":"<p>Algebraic types enable powerful type composition through sum types (OR) and product types (AND).</p>"},{"location":"api/algebraic/#header","title":"Header","text":"<pre><code>#include &lt;pfc/algebraic.hpp&gt;\n</code></pre>"},{"location":"api/algebraic/#packedoptional-maybe","title":"PackedOptional (Maybe)","text":"<p>Represents an optional value that may or may not be present.</p>"},{"location":"api/algebraic/#interface","title":"Interface","text":"<pre><code>template&lt;typename T&gt;\nclass PackedOptional {\npublic:\n    // Constructors\n    PackedOptional();                          // None\n    PackedOptional(std::nullopt_t);           // None\n    PackedOptional(const T&amp; value);           // Some\n    PackedOptional(T&amp;&amp; value);                // Some\n\n    // Queries\n    bool has_value() const;\n    explicit operator bool() const;\n\n    // Access\n    T&amp; value();\n    const T&amp; value() const;\n    T&amp; operator*();\n    const T&amp; operator*() const;\n    T* operator-&gt;();\n    const T* operator-&gt;() const;\n\n    // Fallback\n    T value_or(T default_value) const;\n\n    // Modification\n    void reset();\n    template&lt;typename... Args&gt;\n    T&amp; emplace(Args&amp;&amp;... args);\n\n    // Zero-copy interface\n    size_t byte_size() const;\n    const uint8_t* data() const;\n};\n</code></pre>"},{"location":"api/algebraic/#usage","title":"Usage","text":"<pre><code>using OptionalInt = PackedOptional&lt;Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;&gt;;\n\n// Create values\nOptionalInt some(42);\nOptionalInt none(std::nullopt);\n\n// Check and access\nif (some) {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; *some &lt;&lt; \"\\n\";\n}\n\n// Fallback\nint value = none.value_or(0);\n\n// Pattern matching\nsome.visit(overloaded{\n    [](const auto&amp; v) { std::cout &lt;&lt; \"Some: \" &lt;&lt; v &lt;&lt; \"\\n\"; },\n    []() { std::cout &lt;&lt; \"None\\n\"; }\n});\n</code></pre>"},{"location":"api/algebraic/#packedeither","title":"PackedEither","text":"<p>Represents one of two possible types (tagged union).</p>"},{"location":"api/algebraic/#interface_1","title":"Interface","text":"<pre><code>template&lt;typename L, typename R&gt;\nclass PackedEither {\npublic:\n    // Constructors\n    static PackedEither left(const L&amp; value);\n    static PackedEither right(const R&amp; value);\n\n    // Queries\n    bool is_left() const;\n    bool is_right() const;\n\n    // Access (throws if wrong type)\n    L&amp; left();\n    const L&amp; left() const;\n    R&amp; right();\n    const R&amp; right() const;\n\n    // Visitors\n    template&lt;typename F&gt;\n    auto visit(F&amp;&amp; visitor);\n\n    // Zero-copy interface\n    size_t byte_size() const;\n    const uint8_t* data() const;\n};\n</code></pre>"},{"location":"api/algebraic/#usage_1","title":"Usage","text":"<pre><code>using IntOrString = PackedEither&lt;\n    Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;,\n    PackedString\n&gt;;\n\n// Create values\nauto int_val = IntOrString::left(42);\nauto str_val = IntOrString::right(\"hello\");\n\n// Check type\nif (int_val.is_left()) {\n    std::cout &lt;&lt; \"Int: \" &lt;&lt; int_val.left() &lt;&lt; \"\\n\";\n}\n\n// Pattern matching\nint_val.visit(overloaded{\n    [](int i) { std::cout &lt;&lt; \"Int: \" &lt;&lt; i &lt;&lt; \"\\n\"; },\n    [](const std::string&amp; s) { std::cout &lt;&lt; \"String: \" &lt;&lt; s &lt;&lt; \"\\n\"; }\n});\n</code></pre>"},{"location":"api/algebraic/#packedvariant","title":"PackedVariant","text":"<p>Discriminated union of multiple types.</p>"},{"location":"api/algebraic/#interface_2","title":"Interface","text":"<pre><code>template&lt;typename... Ts&gt;\nclass PackedVariant {\npublic:\n    // Constructors\n    template&lt;size_t I, typename... Args&gt;\n    PackedVariant(std::in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);\n\n    // Queries\n    size_t index() const;\n    template&lt;size_t I&gt;\n    bool holds_alternative() const;\n\n    // Access\n    template&lt;size_t I&gt;\n    auto&amp; get();\n    template&lt;size_t I&gt;\n    const auto&amp; get() const;\n\n    // Visitors\n    template&lt;typename F&gt;\n    auto visit(F&amp;&amp; visitor);\n};\n</code></pre>"},{"location":"api/algebraic/#usage_2","title":"Usage","text":"<pre><code>using Value = PackedVariant&lt;\n    Packed&lt;int, EliasGamma&gt;,\n    PackedString,\n    Packed&lt;double, Float64&gt;\n&gt;;\n\n// Create\nValue int_val(std::in_place_index&lt;0&gt;, 42);\nValue str_val(std::in_place_index&lt;1&gt;, \"hello\");\n\n// Check type\nif (int_val.index() == 0) {\n    std::cout &lt;&lt; int_val.get&lt;0&gt;() &lt;&lt; \"\\n\";\n}\n\n// Exhaustive pattern matching\nint_val.visit(overloaded{\n    [](int i) { std::cout &lt;&lt; \"Int: \" &lt;&lt; i &lt;&lt; \"\\n\"; },\n    [](const std::string&amp; s) { std::cout &lt;&lt; \"String: \" &lt;&lt; s &lt;&lt; \"\\n\"; },\n    [](double d) { std::cout &lt;&lt; \"Double: \" &lt;&lt; d &lt;&lt; \"\\n\"; }\n});\n</code></pre>"},{"location":"api/algebraic/#packedresult","title":"PackedResult","text":"<p>Represents success or error, commonly used for error handling.</p>"},{"location":"api/algebraic/#interface_3","title":"Interface","text":"<pre><code>template&lt;typename T, typename E&gt;\nclass PackedResult {\npublic:\n    // Constructors\n    static PackedResult ok(const T&amp; value);\n    static PackedResult err(const E&amp; error);\n\n    // Queries\n    bool is_ok() const;\n    bool is_err() const;\n    explicit operator bool() const;\n\n    // Access (throws if wrong state)\n    T&amp; unwrap();\n    const T&amp; unwrap() const;\n    E&amp; unwrap_err();\n    const E&amp; unwrap_err() const;\n\n    // Safe access\n    T unwrap_or(T default_value) const;\n    template&lt;typename F&gt;\n    T unwrap_or_else(F&amp;&amp; f) const;\n\n    // Mapping\n    template&lt;typename F&gt;\n    auto map(F&amp;&amp; f) -&gt; PackedResult&lt;decltype(f(std::declval&lt;T&gt;())), E&gt;;\n\n    template&lt;typename F&gt;\n    auto map_err(F&amp;&amp; f) -&gt; PackedResult&lt;T, decltype(f(std::declval&lt;E&gt;()))&gt;;\n\n    // Chaining\n    template&lt;typename F&gt;\n    auto and_then(F&amp;&amp; f);\n\n    // Visitors\n    template&lt;typename F&gt;\n    auto visit(F&amp;&amp; visitor);\n};\n</code></pre>"},{"location":"api/algebraic/#usage_3","title":"Usage","text":"<pre><code>using Result = PackedResult&lt;\n    Packed&lt;int, EliasGamma&gt;,\n    PackedString\n&gt;;\n\n// Create results\nauto success = Result::ok(42);\nauto failure = Result::err(\"Invalid input\");\n\n// Check and access\nif (success.is_ok()) {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; success.unwrap() &lt;&lt; \"\\n\";\n}\n\n// Safe unwrap\nint value = failure.unwrap_or(0);\n\n// Error handling\nauto result = parse_integer(\"42\");\nresult.visit(overloaded{\n    [](int value) { std::cout &lt;&lt; \"Parsed: \" &lt;&lt; value &lt;&lt; \"\\n\"; },\n    [](const std::string&amp; error) { std::cerr &lt;&lt; \"Error: \" &lt;&lt; error &lt;&lt; \"\\n\"; }\n});\n\n// Chaining\nauto result2 = result\n    .map([](int x) { return x * 2; })\n    .and_then([](int x) { return validate(x); });\n</code></pre>"},{"location":"api/algebraic/#packedproduct","title":"PackedProduct","text":"<p>Tuple/struct of multiple values.</p>"},{"location":"api/algebraic/#interface_4","title":"Interface","text":"<pre><code>template&lt;typename... Ts&gt;\nclass PackedProduct {\npublic:\n    // Constructors\n    PackedProduct(const Ts&amp;... values);\n\n    // Access\n    template&lt;size_t I&gt;\n    auto&amp; get();\n    template&lt;size_t I&gt;\n    const auto&amp; get() const;\n\n    // Structured binding support\n    template&lt;size_t I&gt;\n    auto&amp; get() requires (I &lt; sizeof...(Ts));\n};\n</code></pre>"},{"location":"api/algebraic/#usage_4","title":"Usage","text":"<pre><code>using Person = PackedProduct&lt;\n    PackedString,                    // name\n    Packed&lt;uint32_t, EliasGamma&gt;,   // age\n    PackedString                     // email\n&gt;;\n\n// Create\nPerson person(\"Alice\", 30, \"alice@example.com\");\n\n// Access\nstd::cout &lt;&lt; \"Name: \" &lt;&lt; person.get&lt;0&gt;() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Age: \" &lt;&lt; person.get&lt;1&gt;() &lt;&lt; \"\\n\";\n\n// Structured binding (C++17)\nauto&amp; [name, age, email] = person;\nstd::cout &lt;&lt; name &lt;&lt; \" is \" &lt;&lt; age &lt;&lt; \" years old\\n\";\n</code></pre>"},{"location":"api/algebraic/#helper-functions","title":"Helper Functions","text":"<pre><code>// Make optional\ntemplate&lt;typename T&gt;\nauto make_optional(T value) -&gt; PackedOptional&lt;Packed&lt;T&gt;&gt;;\n\n// Make either\ntemplate&lt;typename Either&gt;\nauto make_left(typename Either::left_type value) -&gt; Either;\n\ntemplate&lt;typename Either&gt;\nauto make_right(typename Either::right_type value) -&gt; Either;\n\n// Make result\ntemplate&lt;typename Result&gt;\nauto make_ok(typename Result::value_type value) -&gt; Result;\n\ntemplate&lt;typename Result&gt;\nauto make_err(typename Result::error_type error) -&gt; Result;\n\n// Make product\ntemplate&lt;typename... Ts&gt;\nauto make_product(Ts&amp;&amp;... values) -&gt; PackedProduct&lt;Packed&lt;Ts&gt;...&gt;;\n</code></pre>"},{"location":"api/algebraic/#overloaded-pattern-visitor-helper","title":"Overloaded Pattern (Visitor Helper)","text":"<pre><code>template&lt;typename... Fs&gt;\nstruct overloaded : Fs... {\n    using Fs::operator()...;\n};\n\ntemplate&lt;typename... Fs&gt;\noverloaded(Fs...) -&gt; overloaded&lt;Fs...&gt;;\n</code></pre> <p>Usage with visit:</p> <pre><code>variant.visit(overloaded{\n    [](int i) { /* handle int */ },\n    [](const std::string&amp; s) { /* handle string */ },\n    [](double d) { /* handle double */ }\n});\n</code></pre>"},{"location":"api/algebraic/#see-also","title":"See Also","text":"<ul> <li>Packed Types: Basic packed value types</li> <li>Error Handling Guide: Using Result types</li> <li>Examples: Practical examples</li> </ul>"},{"location":"api/algorithms/","title":"Algorithms API","text":"<p>Generic algorithms optimized for packed data.</p> <pre><code>#include &lt;pfc/algorithms.hpp&gt;\n</code></pre>"},{"location":"api/algorithms/#transform","title":"Transform","text":"<pre><code>template&lt;typename InputIt, typename OutputIt, typename F&gt;\nOutputIt packed_transform(InputIt first, InputIt last,\n                         OutputIt d_first, F&amp;&amp; func);\n</code></pre>"},{"location":"api/algorithms/#filter","title":"Filter","text":"<pre><code>template&lt;typename InputIt, typename OutputIt, typename Pred&gt;\nOutputIt packed_filter(InputIt first, InputIt last,\n                      OutputIt d_first, Pred&amp;&amp; pred);\n</code></pre>"},{"location":"api/algorithms/#reduce","title":"Reduce","text":"<pre><code>template&lt;typename InputIt, typename T, typename BinaryOp&gt;\nT packed_reduce(InputIt first, InputIt last,\n               T init, BinaryOp&amp;&amp; op);\n</code></pre>"},{"location":"api/algorithms/#parallel-execution","title":"Parallel Execution","text":"<p>With TBB support:</p> <pre><code>#include &lt;execution&gt;\n\nauto result = packed_transform(\n    std::execution::par_unseq,\n    data.begin(), data.end(),\n    output.begin(),\n    [](auto x) { return expensive_compute(x); }\n);\n</code></pre> <p>See API Overview for complete documentation.</p>"},{"location":"api/codecs/","title":"Codecs API","text":"<p>Codecs are the foundation of PFC, providing transformations between values and bit representations. All codecs are stateless and use static methods for encoding/decoding.</p>"},{"location":"api/codecs/#codec-concept","title":"Codec Concept","text":"<p>A type <code>C</code> satisfies the <code>Codec&lt;C, T&gt;</code> concept if:</p> <pre><code>template&lt;typename C, typename T&gt;\nconcept Codec = requires(T value, BitSink&amp; sink, BitSource&amp; source) {\n    { C::encode(value, sink) } -&gt; std::same_as&lt;void&gt;;\n    { C::decode(source) } -&gt; std::same_as&lt;T&gt;;\n    { C::is_fixed_size() } -&gt; std::convertible_to&lt;bool&gt;;\n    { C::max_encoded_bits() } -&gt; std::convertible_to&lt;size_t&gt;;\n};\n</code></pre>"},{"location":"api/codecs/#universal-integer-codes","title":"Universal Integer Codes","text":""},{"location":"api/codecs/#unary","title":"Unary","text":"<p>Simplest prefix-free code: n ones followed by a zero.</p> <pre><code>struct Unary {\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 32; }\n};\n</code></pre> <p>Encoding:</p> <ul> <li><code>0</code> \u2192 <code>0</code></li> <li><code>1</code> \u2192 <code>10</code></li> <li><code>2</code> \u2192 <code>110</code></li> <li><code>3</code> \u2192 <code>1110</code></li> </ul> <p>Best for: Very small values (0-10)</p> <p>Size: <code>n + 1</code> bits for value <code>n</code></p>"},{"location":"api/codecs/#eliasgamma","title":"EliasGamma","text":"<p>Encodes <code>n</code> as unary(\u230alog\u2082(n)\u230b) followed by binary(n).</p> <pre><code>struct EliasGamma {\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 64; }\n};\n</code></pre> <p>Encoding:</p> <ul> <li><code>1</code> \u2192 <code>1</code></li> <li><code>2</code> \u2192 <code>010</code></li> <li><code>3</code> \u2192 <code>011</code></li> <li><code>4</code> \u2192 <code>00100</code></li> <li><code>5</code> \u2192 <code>00101</code></li> <li><code>8</code> \u2192 <code>0001000</code></li> </ul> <p>Best for: Small positive integers (1-1000)</p> <p>Size: <code>2\u230alog\u2082(n)\u230b + 1</code> bits</p>"},{"location":"api/codecs/#eliasdelta","title":"EliasDelta","text":"<p>Improves on Gamma by encoding the length using Gamma.</p> <pre><code>struct EliasDelta {\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 64; }\n};\n</code></pre> <p>Best for: Medium positive integers (1-1000000)</p> <p>Size: <code>\u230alog\u2082(n)\u230b + 2\u230alog\u2082(\u230alog\u2082(n)\u230b)\u230b + 1</code> bits</p>"},{"location":"api/codecs/#eliasomega","title":"EliasOmega","text":"<p>Most efficient for large values.</p> <pre><code>struct EliasOmega {\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 64; }\n};\n</code></pre> <p>Best for: Mixed small and large integers</p> <p>Size: <code>O(log n + log log n + log log log n + ...)</code></p>"},{"location":"api/codecs/#fibonacci","title":"Fibonacci","text":"<p>Encodes using Fibonacci representation with special terminator.</p> <pre><code>struct Fibonacci {\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 64; }\n};\n</code></pre> <p>Encoding (Zeckendorf representation + <code>11</code> terminator):</p> <ul> <li><code>1</code> \u2192 <code>11</code></li> <li><code>2</code> \u2192 <code>011</code></li> <li><code>3</code> \u2192 <code>0011</code></li> <li><code>4</code> \u2192 <code>1011</code></li> <li><code>5</code> \u2192 <code>00011</code></li> </ul> <p>Best for: Geometrically distributed values</p> <p>Size: ~1.44 log\u2082(n) bits average</p>"},{"location":"api/codecs/#parametric-codes","title":"Parametric Codes","text":""},{"location":"api/codecs/#rice","title":"Rice","text":"<p>Optimized for geometric distributions with parameter k.</p> <pre><code>template&lt;unsigned K&gt;\nstruct Rice {\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 64; }\n};\n</code></pre> <p>Usage:</p> <pre><code>// For values with mean ~16, use k=4\nusing MyRice = Rice&lt;4&gt;;\nMyRice::encode(42, sink);\n</code></pre> <p>Encoding: Quotient in unary, remainder in k bits</p> <ul> <li><code>q = n &gt;&gt; k</code> (in unary)</li> <li><code>r = n &amp; ((1 &lt;&lt; k) - 1)</code> (in k bits)</li> </ul> <p>Best for: Values with known geometric parameter</p>"},{"location":"api/codecs/#golomb","title":"Golomb","text":"<p>Generalization of Rice to arbitrary divisors.</p> <pre><code>template&lt;unsigned M&gt;\nstruct Golomb {\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 64; }\n};\n</code></pre> <p>Usage:</p> <pre><code>using MyGolomb = Golomb&lt;10&gt;;  // Divisor = 10\nMyGolomb::encode(42, sink);\n</code></pre>"},{"location":"api/codecs/#fixed-width-codes","title":"Fixed-Width Codes","text":""},{"location":"api/codecs/#fixedwidth","title":"FixedWidth","text":"<p>Standard binary representation with N bits.</p> <pre><code>template&lt;unsigned N&gt;\nstruct FixedWidth {\n    template&lt;BitSink S&gt;\n    static void encode(uint64_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static uint64_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() { return true; }\n    static constexpr size_t max_encoded_bits() { return N; }\n};\n</code></pre> <p>Common aliases:</p> <pre><code>using Fixed8 = FixedWidth&lt;8&gt;;\nusing Fixed16 = FixedWidth&lt;16&gt;;\nusing Fixed32 = FixedWidth&lt;32&gt;;\nusing Fixed64 = FixedWidth&lt;64&gt;;\n</code></pre> <p>Best for: Uniformly distributed values, hashes</p>"},{"location":"api/codecs/#signed-integer-encodings","title":"Signed Integer Encodings","text":""},{"location":"api/codecs/#signed","title":"Signed","text":"<p>Wraps any unsigned codec with zigzag encoding.</p> <pre><code>template&lt;typename UnsignedCodec&gt;\nstruct Signed {\n    template&lt;BitSink S&gt;\n    static void encode(int32_t value, S&amp; sink);\n\n    template&lt;BitSource S&gt;\n    static int32_t decode(S&amp; source);\n\n    static constexpr bool is_fixed_size() {\n        return UnsignedCodec::is_fixed_size();\n    }\n    static constexpr size_t max_encoded_bits() {\n        return UnsignedCodec::max_encoded_bits();\n    }\n};\n</code></pre> <p>Zigzag mapping:</p> <pre><code>0  \u2192  0\n-1 \u2192  1\n1  \u2192  2\n-2 \u2192  3\n2  \u2192  4\n</code></pre> <p>Usage:</p> <pre><code>using SignedGamma = Signed&lt;EliasGamma&gt;;\nSignedGamma::encode(-42, sink);\n\nusing SignedDelta = Signed&lt;EliasDelta&gt;;\nPackedVector&lt;Packed&lt;int, SignedDelta&gt;&gt; vec;\n</code></pre>"},{"location":"api/codecs/#codec-selection-guide","title":"Codec Selection Guide","text":"<p>Choose codec based on your data distribution:</p> Data Pattern Best Codec Reason 0-10 Unary Minimal overhead 1-1000 EliasGamma Good average case 1-10^6 EliasDelta Better for larger values Mixed sizes EliasOmega Adapts to magnitude Geometric (many small, few large) Fibonacci, Rice Natural fit Known parameter Rice, Golomb Optimized for distribution Uniform FixedWidth Predictable size Signed integers Signed Efficient negative values"},{"location":"api/codecs/#usage-examples","title":"Usage Examples","text":""},{"location":"api/codecs/#basic-encodingdecoding","title":"Basic Encoding/Decoding","text":"<pre><code>#include &lt;pfc/codecs.hpp&gt;\n\nuint8_t buffer[64] = {};\nBitWriter writer(buffer, sizeof(buffer));\n\n// Encode values\nEliasGamma::encode(42, writer);\nEliasGamma::encode(100, writer);\nEliasDelta::encode(1000000, writer);\nwriter.align();\n\n// Decode\nBitReader reader(buffer, sizeof(buffer));\nauto v1 = EliasGamma::decode(reader);  // 42\nauto v2 = EliasGamma::decode(reader);  // 100\nauto v3 = EliasDelta::decode(reader);  // 1000000\n</code></pre>"},{"location":"api/codecs/#with-packed-values","title":"With Packed Values","text":"<pre><code>// Define packed types\nusing SmallInt = Packed&lt;uint32_t, EliasGamma&gt;;\nusing MediumInt = Packed&lt;uint32_t, EliasDelta&gt;;\nusing LargeInt = Packed&lt;uint32_t, EliasOmega&gt;;\n\n// Use in containers\nPackedVector&lt;SmallInt&gt; small_values;\nsmall_values.push_back(1);\nsmall_values.push_back(10);\nsmall_values.push_back(100);\n</code></pre>"},{"location":"api/codecs/#signed-values","title":"Signed Values","text":"<pre><code>using SignedInt = Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;;\n\nSignedInt positive(42);\nSignedInt negative(-42);\nSignedInt zero(0);\n\n// All efficiently encoded\nPackedVector&lt;SignedInt&gt; vec = {-10, -5, 0, 5, 10};\n</code></pre>"},{"location":"api/codecs/#parametric-codes_1","title":"Parametric Codes","text":"<pre><code>// Audio residuals (small values common)\nusing AudioCodec = Rice&lt;3&gt;;\nPackedVector&lt;Packed&lt;uint32_t, AudioCodec&gt;&gt; residuals;\n\n// Image differences (parameter tuned to statistics)\nusing ImageCodec = Golomb&lt;5&gt;;\nPackedVector&lt;Packed&lt;uint32_t, ImageCodec&gt;&gt; diffs;\n</code></pre>"},{"location":"api/codecs/#performance-comparison","title":"Performance Comparison","text":"<p>Typical sizes for value 1000:</p> Codec Bits Size for 1000 Unary n+1 1001 bits EliasGamma 2\u230alog\u2082(n)\u230b+1 19 bits EliasDelta ~log\u2082(n)+2log\u2082(log\u2082(n)) 13 bits EliasOmega ~log\u2082(n) 12 bits Fibonacci ~1.44log\u2082(n) 15 bits FixedWidth&lt;32&gt; 32 32 bits"},{"location":"api/codecs/#creating-custom-codecs","title":"Creating Custom Codecs","text":"<p>To create your own codec:</p> <pre><code>struct MyCodec {\n    // Required: Is this fixed size?\n    static constexpr bool is_fixed_size() { return false; }\n\n    // Required: Maximum bits needed\n    static constexpr size_t max_encoded_bits() { return 64; }\n\n    // Required: Encode value\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink) {\n        // Your encoding logic\n        sink.write_bit(value &amp; 1);\n        // ...\n    }\n\n    // Required: Decode value\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source) {\n        // Your decoding logic\n        uint32_t value = source.read_bit();\n        // ...\n        return value;\n    }\n};\n</code></pre> <p>See Creating Custom Codecs for detailed guide.</p>"},{"location":"api/codecs/#see-also","title":"See Also","text":"<ul> <li>Core API: BitWriter, BitReader</li> <li>Numeric Codecs: Floating point, rationals</li> <li>Packed Types: Using codecs with values</li> <li>Design Principles: Why prefix-free codes</li> </ul>"},{"location":"api/compression/","title":"Compression API","text":"<p>Advanced compression algorithms beyond basic codecs.</p>"},{"location":"api/compression/#huffman-coding","title":"Huffman Coding","text":"<pre><code>#include &lt;pfc/huffman.hpp&gt;\n\n// Build frequency table\nFrequencyTable freq_table;\nfor (uint8_t byte : data) {\n    freq_table.add(byte);\n}\n\n// Create Huffman tree\nauto huffman_tree = build_huffman_tree(freq_table);\n\n// Compress\nstd::vector&lt;uint8_t&gt; compressed = huffman_encode(data, huffman_tree);\n\n// Decompress\nstd::vector&lt;uint8_t&gt; decompressed = huffman_decode(compressed, huffman_tree);\n</code></pre>"},{"location":"api/compression/#lz77","title":"LZ77","text":"<pre><code>#include &lt;pfc/lz77.hpp&gt;\n\n// Compress with LZ77\nLZ77Encoder encoder;\nauto compressed = encoder.compress(data);\n\n// Decompress\nLZ77Decoder decoder;\nauto decompressed = decoder.decompress(compressed);\n</code></pre>"},{"location":"api/compression/#arithmetic-coding","title":"Arithmetic Coding","text":"<pre><code>#include &lt;pfc/arithmetic_coding.hpp&gt;\n\n// Create probability model\nProbabilityModel model;\n// ... configure model ...\n\n// Encode\nArithmeticEncoder encoder(model);\nauto compressed = encoder.encode(data);\n\n// Decode\nArithmeticDecoder decoder(model);\nauto decompressed = decoder.decode(compressed);\n</code></pre> <p>See Compression Examples for detailed usage.</p>"},{"location":"api/coordinates/","title":"Coordinates API","text":"<p>Geometric types with packed storage.</p> <pre><code>#include &lt;pfc/coordinates.hpp&gt;\n</code></pre>"},{"location":"api/coordinates/#vectors","title":"Vectors","text":"<pre><code>template&lt;typename Codec&gt;\nclass PackedVector2 {\npublic:\n    PackedVector2(double x, double y);\n    double x() const;\n    double y() const;\n    double length() const;\n    double dot(const PackedVector2&amp; other) const;\n};\n\ntemplate&lt;typename Codec&gt;\nclass PackedVector3;  // Similar interface\n\ntemplate&lt;typename Codec&gt;\nclass PackedVector4;\n</code></pre>"},{"location":"api/coordinates/#matrices","title":"Matrices","text":"<pre><code>template&lt;size_t Rows, size_t Cols, typename Codec&gt;\nclass PackedMatrix {\npublic:\n    double operator()(size_t i, size_t j) const;\n    PackedMatrix operator*(const PackedMatrix&amp; other) const;\n};\n</code></pre>"},{"location":"api/coordinates/#transformations","title":"Transformations","text":"<pre><code>template&lt;typename Codec&gt;\nclass AffineTransform {\npublic:\n    static AffineTransform translation(double x, double y, double z);\n    static AffineTransform rotation(double angle, const Vector3&amp; axis);\n    static AffineTransform scale(double sx, double sy, double sz);\n\n    Vector3 apply(const Vector3&amp; point) const;\n};\n</code></pre> <p>See API Overview for complete documentation.</p>"},{"location":"api/core/","title":"Core API","text":"<p>The core module provides fundamental building blocks for bit-level I/O and the conceptual foundation of the library.</p>"},{"location":"api/core/#header","title":"Header","text":"<pre><code>#include &lt;pfc/core.hpp&gt;\n</code></pre>"},{"location":"api/core/#bitwriter","title":"BitWriter","text":"<p>Writes bits to a byte buffer with efficient bit packing.</p>"},{"location":"api/core/#interface","title":"Interface","text":"<pre><code>class BitWriter {\npublic:\n    // Constructors\n    BitWriter(uint8_t* buffer, size_t capacity);\n    BitWriter(std::vector&lt;uint8_t&gt;&amp; buffer);\n    BitWriter(std::span&lt;uint8_t&gt; buffer);\n\n    // Write operations\n    void write_bit(bool bit);\n    void write_bits(uint64_t value, size_t num_bits);\n\n    // Alignment\n    void align();  // Align to next byte boundary\n    void pad_to_byte();  // Pad current byte with zeros\n\n    // State queries\n    size_t bits_written() const;\n    size_t bytes_written() const;\n    size_t capacity() const;\n    bool has_space(size_t num_bits) const;\n\n    // Access\n    const uint8_t* data() const;\n    uint8_t* data();\n};\n</code></pre>"},{"location":"api/core/#usage","title":"Usage","text":"<pre><code>uint8_t buffer[64] = {};\nBitWriter writer(buffer, sizeof(buffer));\n\n// Write individual bits\nwriter.write_bit(true);\nwriter.write_bit(false);\n\n// Write multiple bits\nwriter.write_bits(0b1010, 4);  // Write 4 bits\n\n// Check space\nif (writer.has_space(32)) {\n    writer.write_bits(42, 32);\n}\n\n// Align to byte boundary\nwriter.align();\n\nstd::cout &lt;&lt; \"Wrote \" &lt;&lt; writer.bits_written() &lt;&lt; \" bits (\"\n          &lt;&lt; writer.bytes_written() &lt;&lt; \" bytes)\\n\";\n</code></pre>"},{"location":"api/core/#bitreader","title":"BitReader","text":"<p>Reads bits from a byte buffer.</p>"},{"location":"api/core/#interface_1","title":"Interface","text":"<pre><code>class BitReader {\npublic:\n    // Constructors\n    BitReader(const uint8_t* buffer, size_t size);\n    BitReader(std::span&lt;const uint8_t&gt; buffer);\n    BitReader(const std::vector&lt;uint8_t&gt;&amp; buffer);\n\n    // Read operations\n    bool read_bit();\n    uint64_t read_bits(size_t num_bits);\n\n    // Alignment\n    void align();  // Skip to next byte boundary\n\n    // State queries\n    size_t bits_read() const;\n    size_t bytes_read() const;\n    size_t remaining_bits() const;\n    size_t remaining_bytes() const;\n    bool has_bits(size_t num_bits) const;\n    bool at_end() const;\n\n    // Positioning\n    void skip_bits(size_t num_bits);\n    void reset();  // Reset to beginning\n};\n</code></pre>"},{"location":"api/core/#usage_1","title":"Usage","text":"<pre><code>BitReader reader(buffer, size);\n\n// Read individual bits\nbool b1 = reader.read_bit();\nbool b2 = reader.read_bit();\n\n// Read multiple bits\nuint32_t value = reader.read_bits(32);\n\n// Check availability\nif (reader.has_bits(16)) {\n    uint16_t short_val = reader.read_bits(16);\n}\n\n// Skip bits\nreader.skip_bits(8);\n\n// Check if done\nif (reader.at_end()) {\n    std::cout &lt;&lt; \"Finished reading\\n\";\n}\n</code></pre>"},{"location":"api/core/#concepts","title":"Concepts","text":""},{"location":"api/core/#bitsink","title":"BitSink","text":"<p>Types that can accept bit writes.</p> <pre><code>template&lt;typename T&gt;\nconcept BitSink = requires(T sink, bool bit, uint64_t value, size_t n) {\n    { sink.write_bit(bit) } -&gt; std::same_as&lt;void&gt;;\n    { sink.write_bits(value, n) } -&gt; std::same_as&lt;void&gt;;\n    { sink.align() } -&gt; std::same_as&lt;void&gt;;\n};\n</code></pre> <p>Models: BitWriter, any type with compatible interface</p>"},{"location":"api/core/#bitsource","title":"BitSource","text":"<p>Types that can provide bit reads.</p> <pre><code>template&lt;typename T&gt;\nconcept BitSource = requires(T source, size_t n) {\n    { source.read_bit() } -&gt; std::convertible_to&lt;bool&gt;;\n    { source.read_bits(n) } -&gt; std::convertible_to&lt;uint64_t&gt;;\n    { source.align() } -&gt; std::same_as&lt;void&gt;;\n    { source.at_end() } -&gt; std::convertible_to&lt;bool&gt;;\n};\n</code></pre> <p>Models: BitReader, any type with compatible interface</p>"},{"location":"api/core/#codec","title":"Codec","text":"<p>Types that can encode and decode values.</p> <pre><code>template&lt;typename C, typename T&gt;\nconcept Codec = requires(T value) {\n    { C::encode(value, std::declval&lt;BitSink&amp;&gt;()) } -&gt; std::same_as&lt;void&gt;;\n    { C::decode(std::declval&lt;BitSource&amp;&gt;()) } -&gt; std::same_as&lt;T&gt;;\n    { C::is_fixed_size() } -&gt; std::convertible_to&lt;bool&gt;;\n    { C::max_encoded_bits() } -&gt; std::convertible_to&lt;size_t&gt;;\n};\n</code></pre>"},{"location":"api/core/#packedvalue","title":"PackedValue","text":"<p>Types that maintain zero-copy invariant.</p> <pre><code>template&lt;typename T&gt;\nconcept PackedValue = requires(T value) {\n    { value.byte_size() } -&gt; std::convertible_to&lt;size_t&gt;;\n    { value.data() } -&gt; std::convertible_to&lt;const uint8_t*&gt;;\n    { T::decode(std::declval&lt;std::span&lt;const uint8_t&gt;&gt;()) } -&gt; std::same_as&lt;T&gt;;\n};\n</code></pre>"},{"location":"api/core/#utility-functions","title":"Utility Functions","text":""},{"location":"api/core/#bit-manipulation","title":"Bit Manipulation","text":"<pre><code>// Count leading zeros\nconstexpr uint32_t clz(uint32_t x);\nconstexpr uint64_t clz(uint64_t x);\n\n// Count trailing zeros\nconstexpr uint32_t ctz(uint32_t x);\nconstexpr uint64_t ctz(uint64_t x);\n\n// Population count (number of 1 bits)\nconstexpr uint32_t popcount(uint32_t x);\nconstexpr uint64_t popcount(uint64_t x);\n\n// Bit length (position of highest bit)\nconstexpr uint32_t bit_length(uint32_t x);\nconstexpr uint64_t bit_length(uint64_t x);\n</code></pre>"},{"location":"api/core/#alignment","title":"Alignment","text":"<pre><code>// Round up to next byte boundary\nconstexpr size_t align_to_byte(size_t bit_count);\n\n// Check if aligned\nconstexpr bool is_byte_aligned(size_t bit_count);\n</code></pre>"},{"location":"api/core/#error-handling","title":"Error Handling","text":"<p>Most core operations are noexcept, but may trigger assertions in debug builds:</p> <pre><code>// Debug assertions\nassert(writer.has_space(num_bits));  // Writing without space\nassert(reader.has_bits(num_bits));   // Reading past end\nassert(num_bits &lt;= 64);              // Too many bits requested\n</code></pre>"},{"location":"api/core/#performance","title":"Performance","text":"<ul> <li>BitWriter/BitReader use efficient bitwise operations</li> <li>No dynamic allocation (operate on provided buffers)</li> <li>Branch-free bit manipulation where possible</li> <li>Optimized for sequential access patterns</li> </ul>"},{"location":"api/core/#benchmarks","title":"Benchmarks","text":"<p>Typical performance on modern CPU:</p> <ul> <li>write_bit: ~1-2 ns</li> <li>read_bit: ~1-2 ns</li> <li>write_bits(32): ~2-3 ns</li> <li>read_bits(32): ~2-3 ns</li> </ul>"},{"location":"api/core/#examples","title":"Examples","text":""},{"location":"api/core/#round-trip-encoding","title":"Round-Trip Encoding","text":"<pre><code>#include &lt;pfc/core.hpp&gt;\n\nuint8_t buffer[64];\nBitWriter writer(buffer, sizeof(buffer));\n\n// Encode some data\nwriter.write_bits(0xDEADBEEF, 32);\nwriter.write_bit(true);\nwriter.write_bits(0xFF, 8);\nwriter.align();\n\n// Decode\nBitReader reader(buffer, writer.bytes_written());\nuint32_t value1 = reader.read_bits(32);  // 0xDEADBEEF\nbool flag = reader.read_bit();            // true\nuint8_t byte = reader.read_bits(8);      // 0xFF\n</code></pre>"},{"location":"api/core/#custom-bitsink","title":"Custom BitSink","text":"<pre><code>class FileWriter {\n    std::ofstream file_;\n    uint8_t byte_buffer_;\n    size_t bit_count_;\n\npublic:\n    void write_bit(bool bit) {\n        byte_buffer_ |= (bit &lt;&lt; bit_count_);\n        if (++bit_count_ == 8) {\n            file_.write(reinterpret_cast&lt;char*&gt;(&amp;byte_buffer_), 1);\n            byte_buffer_ = 0;\n            bit_count_ = 0;\n        }\n    }\n\n    void write_bits(uint64_t value, size_t n) {\n        for (size_t i = 0; i &lt; n; ++i) {\n            write_bit((value &gt;&gt; i) &amp; 1);\n        }\n    }\n\n    void align() {\n        if (bit_count_ &gt; 0) {\n            file_.write(reinterpret_cast&lt;char*&gt;(&amp;byte_buffer_), 1);\n            byte_buffer_ = 0;\n            bit_count_ = 0;\n        }\n    }\n};\n\nstatic_assert(BitSink&lt;FileWriter&gt;);\n</code></pre>"},{"location":"api/core/#see-also","title":"See Also","text":"<ul> <li>Codecs API: Using BitWriter/BitReader with codecs</li> <li>Packed Types: High-level packed value types</li> <li>Design Principles: Zero-copy invariant</li> </ul>"},{"location":"api/crc/","title":"CRC API","text":"<p>Cyclic Redundancy Check for data integrity.</p> <pre><code>#include &lt;pfc/crc.hpp&gt;\n</code></pre>"},{"location":"api/crc/#crc8","title":"CRC8","text":"<pre><code>uint8_t checksum = crc8(data.data(), data.size());\n</code></pre>"},{"location":"api/crc/#crc16","title":"CRC16","text":"<pre><code>// CRC-16-CCITT\nuint16_t checksum_ccitt = crc16_ccitt(data.data(), data.size());\n\n// CRC-16-IBM\nuint16_t checksum_ibm = crc16_ibm(data.data(), data.size());\n</code></pre>"},{"location":"api/crc/#crc32","title":"CRC32","text":"<pre><code>// IEEE 802.3 / Ethernet\nuint32_t checksum = crc32(data.data(), data.size());\n</code></pre>"},{"location":"api/crc/#incremental-crc","title":"Incremental CRC","text":"<pre><code>CRC32 crc;\nfor (const auto&amp; chunk : chunks) {\n    crc.update(chunk.data(), chunk.size());\n}\nuint32_t final_checksum = crc.finalize();\n</code></pre>"},{"location":"api/crc/#usage-example","title":"Usage Example","text":"<pre><code>#include &lt;pfc/crc.hpp&gt;\n\n// Add checksum to data\nPackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; data = {1, 2, 3, 4, 5};\nuint32_t checksum = crc32(data.data(), data.byte_size());\n\n// Verify on receive\nuint32_t received_checksum = crc32(received_data.data(),\n                                   received_data.byte_size());\nif (checksum == received_checksum) {\n    std::cout &lt;&lt; \"Data integrity verified\\n\";\n} else {\n    std::cerr &lt;&lt; \"Data corrupted!\\n\";\n}\n</code></pre> <p>See API Overview for complete documentation.</p>"},{"location":"api/error-handling/","title":"Error Handling API","text":"<p>Robust error handling with Result types.</p> <pre><code>#include &lt;pfc/error_handling.hpp&gt;\n</code></pre>"},{"location":"api/error-handling/#result-type","title":"Result Type","text":"<pre><code>template&lt;typename T, typename E&gt;\nclass PackedResult {\npublic:\n    static PackedResult ok(const T&amp; value);\n    static PackedResult err(const E&amp; error);\n\n    bool is_ok() const;\n    bool is_err() const;\n\n    T unwrap();  // Throws if error\n    E unwrap_err();  // Throws if ok\n    T unwrap_or(T default_value) const;\n\n    // Monadic operations\n    template&lt;typename F&gt;\n    auto map(F&amp;&amp; f);\n\n    template&lt;typename F&gt;\n    auto and_then(F&amp;&amp; f);\n};\n</code></pre>"},{"location":"api/error-handling/#usage-example","title":"Usage Example","text":"<pre><code>using Result = PackedResult&lt;Packed&lt;int, EliasGamma&gt;, PackedString&gt;;\n\nResult divide(int a, int b) {\n    if (b == 0) {\n        return Result::err(\"Division by zero\");\n    }\n    return Result::ok(a / b);\n}\n\nauto result = divide(10, 2);\nif (result.is_ok()) {\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result.unwrap() &lt;&lt; \"\\n\";\n} else {\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; result.unwrap_err() &lt;&lt; \"\\n\";\n}\n\n// Chaining\nauto final_result = divide(10, 2)\n    .map([](int x) { return x * 2; })\n    .and_then([](int x) { return divide(x, 5); });\n</code></pre> <p>See Error Handling Guide and Algebraic Types.</p>"},{"location":"api/numeric-codecs/","title":"Numeric Codecs API","text":"<p>Codecs for floating point, rational, and complex numbers.</p>"},{"location":"api/numeric-codecs/#floatingpoint","title":"FloatingPoint","text":"<p>Configurable precision floating point encoding.</p> <pre><code>template&lt;unsigned MantissaBits, unsigned ExponentBits&gt;\nstruct FloatingPoint;\n\n// Standard formats\nusing Float16 = FloatingPoint&lt;11, 5&gt;;   // IEEE 754 half\nusing Float32 = FloatingPoint&lt;24, 8&gt;;   // IEEE 754 single\nusing Float64 = FloatingPoint&lt;53, 11&gt;;  // IEEE 754 double\nusing BFloat16 = FloatingPoint&lt;8, 8&gt;;   // Google Brain float\n</code></pre>"},{"location":"api/numeric-codecs/#rational","title":"Rational","text":"<p>Exact fraction representation.</p> <pre><code>class PackedRational {\npublic:\n    PackedRational(int numerator, int denominator);\n\n    int numerator() const;\n    int denominator() const;\n    double to_double() const;\n};\n</code></pre>"},{"location":"api/numeric-codecs/#complex","title":"Complex","text":"<p>Complex number encoding (rectangular or polar).</p> <pre><code>template&lt;typename FloatCodec&gt;\nclass ComplexRectangular;\n\ntemplate&lt;typename FloatCodec&gt;\nclass ComplexPolar;\n</code></pre> <p>See API Overview for complete documentation.</p>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>PFC provides a comprehensive set of headers organized by functionality. This page gives an overview of the library structure and what each module provides.</p>"},{"location":"api/overview/#header-organization","title":"Header Organization","text":"<pre><code>include/pfc/\n\u251c\u2500\u2500 pfc.hpp                   # Main header (includes everything)\n\u251c\u2500\u2500 core.hpp                  # Fundamental abstractions\n\u251c\u2500\u2500 codecs.hpp                # Universal integer codes\n\u251c\u2500\u2500 numeric_codecs.hpp        # Numeric type codecs\n\u251c\u2500\u2500 packed.hpp                # Packed value types\n\u251c\u2500\u2500 algebraic.hpp             # Algebraic type system\n\u251c\u2500\u2500 stl_integration.hpp       # STL compatibility\n\u251c\u2500\u2500 algorithms.hpp            # Generic algorithms\n\u251c\u2500\u2500 coordinates.hpp           # Vectors, matrices, transforms\n\u251c\u2500\u2500 error_handling.hpp        # Result and error types\n\u251c\u2500\u2500 huffman.hpp               # Huffman coding\n\u251c\u2500\u2500 lz77.hpp                  # LZ77 compression\n\u251c\u2500\u2500 crc.hpp                   # CRC checksums\n\u251c\u2500\u2500 stream_io.hpp             # Stream-based I/O\n\u251c\u2500\u2500 arithmetic_coding.hpp     # Arithmetic coding\n\u2514\u2500\u2500 allocator_support.hpp     # Custom allocator support\n</code></pre>"},{"location":"api/overview/#quick-reference","title":"Quick Reference","text":""},{"location":"api/overview/#including-the-library","title":"Including the Library","text":"<pre><code>#include &lt;pfc/pfc.hpp&gt;          // Everything\n#include &lt;pfc/core.hpp&gt;         // Just core functionality\n#include &lt;pfc/codecs.hpp&gt;       // Just codecs\n</code></pre>"},{"location":"api/overview/#namespace","title":"Namespace","text":"<p>All PFC symbols are in the <code>pfc</code> namespace:</p> <pre><code>using namespace pfc;  // or\npfc::EliasGamma       // explicit qualification\n</code></pre>"},{"location":"api/overview/#core-module","title":"Core Module","text":"<p>Header: <code>core.hpp</code></p> <p>Fundamental building blocks:</p> <ul> <li>BitWriter: Write bits to a buffer</li> <li>BitReader: Read bits from a buffer</li> <li>Concepts: BitSink, BitSource, Codec, PackedValue</li> <li>Utilities: Bit manipulation, alignment</li> </ul> <p>Detailed Core API \u2192</p>"},{"location":"api/overview/#codecs-module","title":"Codecs Module","text":"<p>Header: <code>codecs.hpp</code></p> <p>Universal integer codes and fixed-width encodings:</p> <ul> <li>Unary: Simple unary code</li> <li>EliasGamma: Good for small integers</li> <li>EliasDelta: Good for medium integers</li> <li>EliasOmega: Good for mixed distributions</li> <li>Fibonacci: Based on Fibonacci sequence</li> <li>Rice/Golomb: Parametric codes</li> <li>FixedWidth: Fixed N-bit encoding <li>Signed: Zigzag encoding for signed values <p>Detailed Codecs API \u2192</p>"},{"location":"api/overview/#numeric-codecs-module","title":"Numeric Codecs Module","text":"<p>Header: <code>numeric_codecs.hpp</code></p> <p>Floating point and numeric types:</p> <ul> <li>FloatingPoint: Configurable precision <li>Float16, Float32, Float64: Standard formats</li> <li>FixedDecimal: Exact decimal representation</li> <li>Rational: Fraction encoding</li> <li>Complex: Complex number encoding</li> <p>Detailed Numeric Codecs API \u2192</p>"},{"location":"api/overview/#packed-values-module","title":"Packed Values Module","text":"<p>Header: <code>packed.hpp</code></p> <p>Zero-copy value types:</p> <ul> <li>Packed: Single packed value <li>PackedVector: Dynamic array of packed values <li>PackedString: Variable-length string</li> <li>PackedArray: Fixed-size array <li>PackedList: Linked list <p>Detailed Packed Types API \u2192</p>"},{"location":"api/overview/#algebraic-types-module","title":"Algebraic Types Module","text":"<p>Header: <code>algebraic.hpp</code></p> <p>Type composition and sum/product types:</p> <ul> <li>PackedOptional: Nullable value (Maybe) <li>PackedEither: Either left or right <li>PackedVariant: Discriminated union <li>PackedProduct: Tuple/struct <li>PackedResult: Success or error <p>Detailed Algebraic Types API \u2192</p>"},{"location":"api/overview/#stl-integration-module","title":"STL Integration Module","text":"<p>Header: <code>stl_integration.hpp</code></p> <p>STL-compatible containers and iterators:</p> <ul> <li>PackedContainer: STL-style container <li>PackedIterator: Random access iterator <li>Proxy references: Decode-on-access</li> <li>Standard algorithms: sort, find, accumulate, etc.</li> <p>Detailed STL Integration API \u2192</p>"},{"location":"api/overview/#algorithms-module","title":"Algorithms Module","text":"<p>Header: <code>algorithms.hpp</code></p> <p>Generic algorithms for packed data:</p> <ul> <li>packed_transform: Transform elements</li> <li>packed_filter: Filter by predicate</li> <li>packed_reduce: Fold/accumulate</li> <li>packed_map: Map and collect</li> <li>Parallel execution: TBB support</li> </ul> <p>Detailed Algorithms API \u2192</p>"},{"location":"api/overview/#coordinates-module","title":"Coordinates Module","text":"<p>Header: <code>coordinates.hpp</code></p> <p>Geometric types and transformations:</p> <ul> <li>PackedVector2/3/4: 2D/3D/4D vectors</li> <li>PackedMatrix: Matrices</li> <li>PackedQuaternion: Rotations</li> <li>AffineTransform: Transformations</li> <li>Operations: Dot, cross, matrix multiplication</li> </ul> <p>Detailed Coordinates API \u2192</p>"},{"location":"api/overview/#error-handling-module","title":"Error Handling Module","text":"<p>Header: <code>error_handling.hpp</code></p> <p>Robust error handling:</p> <ul> <li>Result: Success or error <li>Error types: Structured error information</li> <li>Error propagation: Chainable operations</li> <li>Pattern matching: Visit for exhaustive handling</li> <p>Detailed Error Handling API \u2192</p>"},{"location":"api/overview/#compression-module","title":"Compression Module","text":"<p>Headers: <code>huffman.hpp</code>, <code>lz77.hpp</code>, <code>arithmetic_coding.hpp</code></p> <p>Data compression algorithms:</p> <ul> <li>Huffman coding: Static and dynamic tables</li> <li>LZ77: Dictionary-based compression</li> <li>Arithmetic coding: Range encoding</li> <li>Combined approaches: Hybrid compression</li> </ul> <p>Detailed Compression API \u2192</p>"},{"location":"api/overview/#crc-module","title":"CRC Module","text":"<p>Header: <code>crc.hpp</code></p> <p>Cyclic redundancy check:</p> <ul> <li>CRC8: 8-bit checksum</li> <li>CRC16: 16-bit checksum (CCITT, IBM)</li> <li>CRC32: 32-bit checksum (IEEE 802.3)</li> <li>Incremental: Update as data arrives</li> </ul> <p>Detailed CRC API \u2192</p>"},{"location":"api/overview/#common-types","title":"Common Types","text":""},{"location":"api/overview/#size-types","title":"Size Types","text":"<pre><code>using size_t = std::size_t;         // Container sizes\nusing bit_size_t = uint64_t;        // Bit counts\n</code></pre>"},{"location":"api/overview/#concepts","title":"Concepts","text":"<pre><code>template&lt;typename T&gt;\nconcept BitSink = /* can write bits */;\n\ntemplate&lt;typename T&gt;\nconcept BitSource = /* can read bits */;\n\ntemplate&lt;typename C, typename T&gt;\nconcept Codec = /* can encode/decode T */;\n\ntemplate&lt;typename T&gt;\nconcept PackedValue = /* has encode/decode */;\n</code></pre>"},{"location":"api/overview/#high-level-api","title":"High-Level API","text":""},{"location":"api/overview/#compression-functions","title":"Compression Functions","text":"<pre><code>// Compress a vector\ntemplate&lt;typename Codec = EliasGamma, typename T&gt;\nstd::vector&lt;uint8_t&gt; compress(const std::vector&lt;T&gt;&amp; data);\n\n// Decompress to vector\ntemplate&lt;typename Codec = EliasGamma, typename T&gt;\nstd::vector&lt;T&gt; decompress(std::span&lt;const uint8_t&gt; compressed);\n</code></pre>"},{"location":"api/overview/#convenience-constructors","title":"Convenience Constructors","text":"<pre><code>// Make packed optional\ntemplate&lt;typename T&gt;\nauto make_optional(T value) -&gt; PackedOptional&lt;Packed&lt;T&gt;&gt;;\n\n// Make either left\ntemplate&lt;typename Either&gt;\nauto make_left(typename Either::left_type value) -&gt; Either;\n\n// Make result ok\ntemplate&lt;typename Result&gt;\nauto make_ok(typename Result::value_type value) -&gt; Result;\n</code></pre>"},{"location":"api/overview/#type-aliases","title":"Type Aliases","text":"<p>Common type aliases for convenience:</p> <pre><code>// Integers\nusing PackedInt = Packed&lt;uint32_t, EliasGamma&gt;;\nusing PackedLong = Packed&lt;uint64_t, EliasDelta&gt;;\n\n// Floating point\nusing PackedFloat = Packed&lt;float, Float32&gt;;\nusing PackedDouble = Packed&lt;double, Float64&gt;;\n\n// Strings\nusing PackedString = PackedVector&lt;Packed&lt;char, FixedWidth&lt;8&gt;&gt;&gt;;\n\n// Collections\ntemplate&lt;typename T&gt;\nusing PackedVec = PackedVector&lt;Packed&lt;T, EliasGamma&gt;&gt;;\n</code></pre>"},{"location":"api/overview/#constants","title":"Constants","text":"<pre><code>// Maximum encoded sizes\nconstexpr size_t MAX_ELIAS_GAMMA_BITS = 64;\nconstexpr size_t MAX_ELIAS_DELTA_BITS = 64;\n\n// Special values\nconstexpr uint32_t INVALID_INDEX = ~0u;\n</code></pre>"},{"location":"api/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Explore specific modules in detail</li> <li>Check out examples for usage patterns</li> <li>Read design principles for philosophy</li> </ul>"},{"location":"api/packed/","title":"Packed Types API","text":"<p>Packed types maintain the zero-copy invariant by storing values in compressed form.</p>"},{"location":"api/packed/#packed","title":"Packed","text":"<p>Single packed value with specified codec.</p> <pre><code>template&lt;typename T, typename Codec&gt;\nclass Packed {\npublic:\n    Packed();\n    explicit Packed(const T&amp; value);\n\n    T get() const;\n    operator T() const;\n\n    size_t byte_size() const;\n    const uint8_t* data() const;\n\n    bool operator==(const Packed&amp; other) const;\n    bool operator!=(const Packed&amp; other) const;\n    bool operator&lt;(const Packed&amp; other) const;\n};\n</code></pre>"},{"location":"api/packed/#packedvector","title":"PackedVector","text":"<p>Dynamic array with zero-copy semantics.</p> <pre><code>template&lt;typename T&gt;\nclass PackedVector {\npublic:\n    using value_type = T;\n    using iterator = /* proxy iterator */;\n\n    PackedVector();\n    explicit PackedVector(size_t count);\n\n    void push_back(const T&amp; value);\n    void pop_back();\n    T operator[](size_t index) const;\n    T at(size_t index) const;\n\n    size_t size() const;\n    bool empty() const;\n    void clear();\n\n    iterator begin();\n    iterator end();\n\n    size_t byte_size() const;\n    const uint8_t* data() const;\n};\n</code></pre> <p>See API Overview for complete documentation.</p>"},{"location":"api/stl-integration/","title":"STL Integration API","text":"<p>PFC containers and iterators work seamlessly with STL algorithms.</p>"},{"location":"api/stl-integration/#packedcontainer","title":"PackedContainer","text":"<p>STL-compatible container with packed storage.</p> <pre><code>template&lt;typename T, typename Codec&gt;\nclass PackedContainer {\npublic:\n    using value_type = T;\n    using iterator = /* random access iterator */;\n    using const_iterator = /* const random access iterator */;\n\n    // STL interface\n    iterator begin();\n    iterator end();\n    const_iterator begin() const;\n    const_iterator end() const;\n    const_iterator cbegin() const;\n    const_iterator cend() const;\n\n    size_t size() const;\n    bool empty() const;\n    void clear();\n\n    void push_back(const T&amp; value);\n    void pop_back();\n    T operator[](size_t index) const;\n};\n</code></pre>"},{"location":"api/stl-integration/#stl-algorithm-compatibility","title":"STL Algorithm Compatibility","text":"<p>All standard algorithms work:</p> <pre><code>PackedContainer&lt;uint32_t, EliasGamma&gt; data;\n\n// Sorting\nstd::sort(data.begin(), data.end());\nstd::stable_sort(data.begin(), data.end());\n\n// Searching\nauto it = std::find(data.begin(), data.end(), 42);\nauto it2 = std::binary_search(data.begin(), data.end(), 42);\n\n// Accumulation\nauto sum = std::accumulate(data.begin(), data.end(), 0);\n\n// Transformation\nstd::transform(data.begin(), data.end(), data.begin(),\n               [](auto x) { return x * 2; });\n</code></pre> <p>See API Overview for complete documentation.</p>"},{"location":"examples/advanced/","title":"Advanced Examples","text":"<p>Complex real-world scenarios.</p> <p>See Basic Examples for introductory material.</p> <p>(Content to be expanded with advanced examples)</p>"},{"location":"examples/algebraic/","title":"Algebraic Types Examples","text":"<p>Working with sum and product types.</p> <p>See API Reference for complete documentation.</p> <p>(Content to be expanded with algebraic type examples)</p>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":"<p>This page demonstrates fundamental PFC usage patterns for common tasks.</p>"},{"location":"examples/basic/#simple-compression","title":"Simple Compression","text":"<p>Compress and decompress a vector of integers:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace pfc;\n\nint main() {\n    // Original data\n    std::vector&lt;uint32_t&gt; data = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89};\n\n    // Compress using default codec (EliasGamma)\n    auto compressed = compress(data);\n\n    // Decompress\n    auto decompressed = decompress&lt;uint32_t&gt;(compressed);\n\n    // Verify\n    assert(data == decompressed);\n\n    // Show compression ratio\n    std::cout &lt;&lt; \"Original: \" &lt;&lt; data.size() * sizeof(uint32_t) &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Compressed: \" &lt;&lt; compressed.size() &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Ratio: \" &lt;&lt; (data.size() * sizeof(uint32_t)) / (double)compressed.size() &lt;&lt; \"x\\n\";\n}\n</code></pre> <p>Output: <pre><code>Original: 40 bytes\nCompressed: 12 bytes\nRatio: 3.33x\n</code></pre></p>"},{"location":"examples/basic/#choosing-different-codecs","title":"Choosing Different Codecs","text":"<p>Different codecs work better for different data distributions:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n#include &lt;random&gt;\n\nusing namespace pfc;\n\nint main() {\n    std::mt19937 gen(42);\n\n    // Small numbers - use Elias Gamma\n    std::geometric_distribution&lt;&gt; small_dist(0.3);\n    std::vector&lt;uint32_t&gt; small_nums;\n    for (int i = 0; i &lt; 1000; ++i) {\n        small_nums.push_back(small_dist(gen));\n    }\n    auto compressed_gamma = compress&lt;EliasGamma&gt;(small_nums);\n\n    // Medium numbers - use Elias Delta\n    std::uniform_int_distribution&lt;uint32_t&gt; med_dist(0, 100000);\n    std::vector&lt;uint32_t&gt; med_nums;\n    for (int i = 0; i &lt; 1000; ++i) {\n        med_nums.push_back(med_dist(gen));\n    }\n    auto compressed_delta = compress&lt;EliasDelta&gt;(med_nums);\n\n    // Compare\n    std::cout &lt;&lt; \"Small nums with Gamma: \" &lt;&lt; compressed_gamma.size() &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Medium nums with Delta: \" &lt;&lt; compressed_delta.size() &lt;&lt; \" bytes\\n\";\n}\n</code></pre>"},{"location":"examples/basic/#working-with-packed-values","title":"Working with Packed Values","text":"<p>Packed values maintain compressed representation:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\nint main() {\n    // Define a packed integer type\n    using PackedInt = Packed&lt;uint32_t, EliasGamma&gt;;\n\n    // Create packed values\n    PackedInt a(42);\n    PackedInt b(100);\n\n    // Values are stored in compressed form\n    std::cout &lt;&lt; \"Packed size of a: \" &lt;&lt; a.byte_size() &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Packed size of b: \" &lt;&lt; b.byte_size() &lt;&lt; \" bytes\\n\";\n\n    // Decode on access\n    uint32_t decoded_a = a.get();\n    uint32_t decoded_b = b.get();\n\n    // Comparison works directly\n    assert(a != b);\n\n    // Can be copied efficiently\n    PackedInt c = a;\n    assert(c == a);\n}\n</code></pre>"},{"location":"examples/basic/#packed-containers","title":"Packed Containers","text":"<p>Use PackedVector for dynamic collections:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace pfc;\n\nint main() {\n    // Create a packed vector\n    PackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; vec;\n\n    // Add elements\n    for (uint32_t i = 1; i &lt;= 10; ++i) {\n        vec.push_back(i * i);  // 1, 4, 9, 16, 25, ...\n    }\n\n    // Access elements (decoded on demand)\n    for (const auto&amp; value : vec) {\n        std::cout &lt;&lt; value &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // Works with STL algorithms\n    auto sum = std::accumulate(vec.begin(), vec.end(), 0u);\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; sum &lt;&lt; \"\\n\";\n\n    // Sorting\n    std::sort(vec.begin(), vec.end(), std::greater&lt;&gt;());\n\n    // Finding\n    auto it = std::find(vec.begin(), vec.end(), 25);\n    if (it != vec.end()) {\n        std::cout &lt;&lt; \"Found 25 at index \" &lt;&lt; std::distance(vec.begin(), it) &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"examples/basic/#strings","title":"Strings","text":"<p>PackedString provides compressed string storage:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\nint main() {\n    // Create strings\n    PackedString str1(\"Hello, PFC!\");\n    PackedString str2(\"Compressed strings\");\n\n    // Conversion\n    std::string std_str = str1.to_string();\n\n    // Comparison\n    assert(str1 != str2);\n\n    // Concatenation (via conversion)\n    PackedString str3(str1.to_string() + \" \" + str2.to_string());\n\n    // Access characters\n    for (size_t i = 0; i &lt; str1.size(); ++i) {\n        std::cout &lt;&lt; str1[i];\n    }\n    std::cout &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"examples/basic/#signed-integers","title":"Signed Integers","text":"<p>Use Signed codec wrapper for negative values:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\nint main() {\n    // Define signed packed type\n    using SignedInt = Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;;\n\n    // Create values\n    SignedInt positive(42);\n    SignedInt negative(-42);\n    SignedInt zero(0);\n\n    // All efficiently encoded using zigzag\n    std::cout &lt;&lt; \"Positive size: \" &lt;&lt; positive.byte_size() &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Negative size: \" &lt;&lt; negative.byte_size() &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Zero size: \" &lt;&lt; zero.byte_size() &lt;&lt; \" bytes\\n\";\n\n    // Vector of signed integers\n    PackedVector&lt;SignedInt&gt; vec = {-10, -5, 0, 5, 10};\n\n    // Works naturally with signed arithmetic\n    for (auto val : vec) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"examples/basic/#file-io","title":"File I/O","text":"<p>Save and load packed data:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n#include &lt;fstream&gt;\n\nusing namespace pfc;\n\nvoid save_data(const std::string&amp; filename,\n               const PackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt;&amp; vec) {\n    std::ofstream file(filename, std::ios::binary);\n    if (!file) {\n        throw std::runtime_error(\"Cannot open file\");\n    }\n\n    // Write size\n    uint32_t size = vec.size();\n    file.write(reinterpret_cast&lt;const char*&gt;(&amp;size), sizeof(size));\n\n    // Write packed data directly\n    file.write(reinterpret_cast&lt;const char*&gt;(vec.data()), vec.byte_size());\n}\n\nPackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; load_data(const std::string&amp; filename) {\n    std::ifstream file(filename, std::ios::binary);\n    if (!file) {\n        throw std::runtime_error(\"Cannot open file\");\n    }\n\n    // Read size\n    uint32_t size;\n    file.read(reinterpret_cast&lt;char*&gt;(&amp;size), sizeof(size));\n\n    // Read packed data\n    std::vector&lt;uint8_t&gt; buffer(size * 10);  // Estimate\n    file.read(reinterpret_cast&lt;char*&gt;(buffer.data()), buffer.size());\n\n    // Construct from buffer\n    return PackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt;(buffer.data(), buffer.size());\n}\n\nint main() {\n    // Create and save\n    PackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; vec = {1, 2, 3, 5, 8, 13};\n    save_data(\"data.bin\", vec);\n\n    // Load\n    auto loaded = load_data(\"data.bin\");\n\n    // Verify\n    assert(vec == loaded);\n}\n</code></pre>"},{"location":"examples/basic/#network-transmission","title":"Network Transmission","text":"<p>Send packed data over network:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n#include &lt;sys/socket.h&gt;\n\nusing namespace pfc;\n\nvoid send_packed_data(int socket, const PackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt;&amp; vec) {\n    // Send size header\n    uint32_t size = vec.byte_size();\n    send(socket, &amp;size, sizeof(size), 0);\n\n    // Send packed data directly (zero-copy)\n    send(socket, vec.data(), size, 0);\n}\n\nPackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; receive_packed_data(int socket) {\n    // Receive size\n    uint32_t size;\n    recv(socket, &amp;size, sizeof(size), MSG_WAITALL);\n\n    // Receive data\n    std::vector&lt;uint8_t&gt; buffer(size);\n    recv(socket, buffer.data(), size, MSG_WAITALL);\n\n    // Zero-copy construction\n    return PackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt;(buffer.data(), buffer.size());\n}\n</code></pre>"},{"location":"examples/basic/#configuration-storage","title":"Configuration Storage","text":"<p>Store configuration with mixed types:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\nstruct Config {\n    PackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; allowed_ports;\n    PackedString server_name;\n    Packed&lt;uint32_t, FixedWidth&lt;32&gt;&gt; flags;\n    Packed&lt;float, Float32&gt; timeout;\n};\n\nint main() {\n    // Create configuration\n    Config config;\n    config.allowed_ports = {80, 443, 8080};\n    config.server_name = PackedString(\"MyServer\");\n    config.flags = Packed&lt;uint32_t, FixedWidth&lt;32&gt;&gt;(0xFF00);\n    config.timeout = Packed&lt;float, Float32&gt;(30.0f);\n\n    // Each field maintains compressed representation\n    std::cout &lt;&lt; \"Ports size: \" &lt;&lt; config.allowed_ports.byte_size() &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Name size: \" &lt;&lt; config.server_name.byte_size() &lt;&lt; \" bytes\\n\";\n\n    // Access values\n    for (auto port : config.allowed_ports) {\n        std::cout &lt;&lt; \"Port: \" &lt;&lt; port &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; \"Server: \" &lt;&lt; config.server_name.to_string() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Timeout: \" &lt;&lt; config.timeout.get() &lt;&lt; \"s\\n\";\n}\n</code></pre>"},{"location":"examples/basic/#bit-level-operations","title":"Bit-Level Operations","text":"<p>Low-level bit manipulation:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\nint main() {\n    uint8_t buffer[64] = {};\n\n    // Writing\n    {\n        BitWriter writer(buffer, sizeof(buffer));\n\n        // Write individual bits\n        writer.write_bit(1);\n        writer.write_bit(0);\n        writer.write_bit(1);\n\n        // Write multiple bits\n        writer.write_bits(0b1010, 4);\n\n        // Write with different codecs\n        EliasGamma::encode(42, writer);\n        EliasDelta::encode(1000, writer);\n\n        // Align to byte boundary\n        writer.align();\n\n        std::cout &lt;&lt; \"Wrote \" &lt;&lt; writer.bits_written() &lt;&lt; \" bits\\n\";\n    }\n\n    // Reading\n    {\n        BitReader reader(buffer, sizeof(buffer));\n\n        // Read individual bits\n        bool b1 = reader.read_bit();\n        bool b2 = reader.read_bit();\n        bool b3 = reader.read_bit();\n\n        // Read multiple bits\n        uint32_t nibble = reader.read_bits(4);\n\n        // Read with codecs\n        auto v1 = EliasGamma::decode(reader);\n        auto v2 = EliasDelta::decode(reader);\n\n        std::cout &lt;&lt; \"Read values: \" &lt;&lt; v1 &lt;&lt; \", \" &lt;&lt; v2 &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<ul> <li>Codec Examples: Detailed codec usage</li> <li>Container Examples: Advanced container operations</li> <li>Algebraic Types Examples: Sum and product types</li> <li>Compression Examples: Huffman, LZ77</li> </ul>"},{"location":"examples/codecs/","title":"Codec Examples","text":"<p>Detailed examples for different codecs.</p> <p>See Basic Examples for introductory material and API Reference for complete documentation.</p> <p>(Content to be expanded with specific codec use cases)</p>"},{"location":"examples/compression/","title":"Compression Examples","text":"<p>Using Huffman, LZ77, and arithmetic coding.</p> <p>See API Reference for complete documentation.</p> <p>(Content to be expanded with compression examples)</p>"},{"location":"examples/containers/","title":"Container Examples","text":"<p>Advanced container usage patterns.</p> <p>See Basic Examples for introductory material and API Reference for complete documentation.</p> <p>(Content to be expanded with container examples)</p>"},{"location":"guides/best-practices/","title":"Best Practices","text":"<p>Guidelines for effective use of PFC in production code.</p>"},{"location":"guides/best-practices/#type-aliases","title":"Type Aliases","text":"<p>Create meaningful type aliases:</p> <pre><code>// Good: Descriptive names\nusing UserId = Packed&lt;uint32_t, EliasGamma&gt;;\nusing UserName = PackedString;\nusing UserAge = Packed&lt;uint8_t, FixedWidth&lt;8&gt;&gt;;\n\n// Better: Semantic types\nstruct User {\n    UserId id;\n    UserName name;\n    UserAge age;\n};\n</code></pre>"},{"location":"guides/best-practices/#const-correctness","title":"Const Correctness","text":"<p>Use const for immutable data:</p> <pre><code>void process(const PackedVector&lt;PackedInt&gt;&amp; data) {\n    // Can't modify data\n    for (const auto&amp; value : data) {\n        std::cout &lt;&lt; value &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"guides/best-practices/#error-handling","title":"Error Handling","text":"<p>Prefer Result types over exceptions:</p> <pre><code>using ParseResult = PackedResult&lt;PackedInt, PackedString&gt;;\n\nParseResult parse(const std::string&amp; input) {\n    // Return Result instead of throwing\n}\n</code></pre>"},{"location":"guides/best-practices/#testing","title":"Testing","text":"<p>Test codec round-trips thoroughly:</p> <pre><code>TEST_CASE(\"Codec correctness\") {\n    for (uint32_t value = 0; value &lt; 10000; ++value) {\n        uint8_t buffer[64];\n        BitWriter writer(buffer);\n        MyCodec::encode(value, writer);\n        writer.align();\n\n        BitReader reader(buffer);\n        auto decoded = MyCodec::decode(reader);\n        REQUIRE(decoded == value);\n    }\n}\n</code></pre>"},{"location":"guides/best-practices/#documentation","title":"Documentation","text":"<p>Document codec choices:</p> <pre><code>// Using Rice&lt;4&gt; because our data follows geometric distribution\n// with parameter ~16, making k=4 optimal\nusing PacketSize = Packed&lt;uint32_t, Rice&lt;4&gt;&gt;;\n</code></pre>"},{"location":"guides/best-practices/#performance","title":"Performance","text":"<p>Profile before optimizing:</p> <pre><code>// Measure first\nauto start = std::chrono::high_resolution_clock::now();\nprocess_data(packed_vec);\nauto end = std::chrono::high_resolution_clock::now();\n\n// Then optimize if needed\n</code></pre>"},{"location":"guides/best-practices/#code-organization","title":"Code Organization","text":"<p>Separate concerns:</p> <pre><code>project/\n  include/\n    types.hpp        # Type definitions\n    codecs.hpp       # Custom codecs\n    serialization.hpp # Serialization logic\n  src/\n    main.cpp\n  tests/\n    test_codecs.cpp\n</code></pre> <p>See Design Principles for philosophical guidance.</p>"},{"location":"guides/custom-codecs/","title":"Creating Custom Codecs","text":"<p>Learn how to extend PFC with your own codec implementations.</p>"},{"location":"guides/custom-codecs/#codec-requirements","title":"Codec Requirements","text":"<p>A codec must implement:</p> <pre><code>struct MyCodec {\n    // Required: Is size fixed?\n    static constexpr bool is_fixed_size();\n\n    // Required: Maximum encoded bits\n    static constexpr size_t max_encoded_bits();\n\n    // Required: Encode value\n    template&lt;BitSink S&gt;\n    static void encode(ValueType value, S&amp; sink);\n\n    // Required: Decode value\n    template&lt;BitSource S&gt;\n    static ValueType decode(S&amp; source);\n};\n</code></pre>"},{"location":"guides/custom-codecs/#example-run-length-encoding","title":"Example: Run-Length Encoding","text":"<pre><code>struct RunLengthCodec {\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 128; }\n\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink) {\n        // Encode run length and value\n        EliasGamma::encode(value &amp; 0xFF, sink);  // Value\n        EliasGamma::encode(value &gt;&gt; 8, sink);     // Count\n    }\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source) {\n        uint32_t value = EliasGamma::decode(source);\n        uint32_t count = EliasGamma::decode(source);\n        return value | (count &lt;&lt; 8);\n    }\n};\n</code></pre>"},{"location":"guides/custom-codecs/#using-your-codec","title":"Using Your Codec","text":"<p>Once defined, your codec works with all PFC infrastructure:</p> <pre><code>// With packed values\nusing Packed RLE = Packed&lt;uint32_t, RunLengthCodec&gt;;\n\n// With containers\nPackedVector&lt;PackedRLE&gt; vec;\n\n// With compression API\nauto compressed = compress&lt;RunLengthCodec&gt;(data);\n</code></pre>"},{"location":"guides/custom-codecs/#testing-your-codec","title":"Testing Your Codec","text":"<p>Always test round-trip correctness:</p> <pre><code>TEST_CASE(\"RunLengthCodec round-trip\") {\n    uint8_t buffer[64];\n    BitWriter writer(buffer);\n\n    uint32_t original = 0x0102;\n    RunLengthCodec::encode(original, writer);\n    writer.align();\n\n    BitReader reader(buffer);\n    uint32_t decoded = RunLengthCodec::decode(reader);\n\n    REQUIRE(decoded == original);\n}\n</code></pre> <p>See Design Principles for codec design philosophy.</p>"},{"location":"guides/design-principles/","title":"Design Principles","text":"<p>PFC is built on a foundation of rigorous design principles inspired by Alex Stepanov's work on generic programming and the STL. Understanding these principles will help you use the library effectively and extend it correctly.</p>"},{"location":"guides/design-principles/#the-zero-copy-invariant","title":"The Zero-Copy Invariant","text":"<p>Principle: In-memory representation equals wire format.</p> <p>Traditional serialization involves two copies:</p> <pre><code>Value -&gt; Serialized Bytes -&gt; Value\n</code></pre> <p>PFC eliminates this overhead:</p> <pre><code>PackedValue = Bytes (same representation)\n</code></pre>"},{"location":"guides/design-principles/#benefits","title":"Benefits","text":"<ol> <li>Performance: No marshaling overhead</li> <li>Memory: Single canonical representation</li> <li>Simplicity: What you store is what you send</li> </ol>"},{"location":"guides/design-principles/#implementation","title":"Implementation","text":"<p>All packed types maintain bit-level representation:</p> <pre><code>class PackedInt {\n    std::vector&lt;uint8_t&gt; bytes_;  // Stored in encoded form\n\npublic:\n    uint32_t get() const {\n        BitReader reader(bytes_.data(), bytes_.size());\n        return EliasGamma::decode(reader);  // Decode on access\n    }\n};\n</code></pre>"},{"location":"guides/design-principles/#prefix-free-codes","title":"Prefix-Free Codes","text":"<p>Principle: All encodings are self-delimiting.</p> <p>A prefix-free code ensures no codeword is a prefix of another. This enables:</p> <ul> <li>Streaming without lookahead</li> <li>Concatenation without separators</li> <li>Guaranteed unique decoding</li> </ul>"},{"location":"guides/design-principles/#example","title":"Example","text":"<p>Elias Gamma encoding of integers:</p> <pre><code>1  -&gt; 1\n2  -&gt; 010\n3  -&gt; 011\n4  -&gt; 00100\n5  -&gt; 00101\n</code></pre> <p>No codeword is a prefix of another, enabling unambiguous decoding:</p> <pre><code>BitStream: 1 010 00100\nDecodes to: [1, 2, 4]\n</code></pre>"},{"location":"guides/design-principles/#regular-types","title":"Regular Types","text":"<p>Principle: All types satisfy Stepanov's concept of regular types.</p> <p>A regular type supports:</p> <ul> <li>Default construction</li> <li>Copy construction and assignment</li> <li>Move construction and assignment</li> <li>Equality comparison</li> <li>Destruction</li> </ul>"},{"location":"guides/design-principles/#why-it-matters","title":"Why It Matters","text":"<p>Regular types can be:</p> <ul> <li>Stored in containers</li> <li>Passed by value</li> <li>Used with algorithms</li> <li>Reasoned about mathematically</li> </ul>"},{"location":"guides/design-principles/#implementation_1","title":"Implementation","text":"<pre><code>template&lt;typename T, typename Codec&gt;\nclass Packed {\npublic:\n    Packed() = default;                           // Default construct\n    Packed(const Packed&amp;) = default;              // Copy\n    Packed(Packed&amp;&amp;) noexcept = default;          // Move\n    Packed&amp; operator=(const Packed&amp;) = default;   // Copy assign\n    Packed&amp; operator=(Packed&amp;&amp;) noexcept = default; // Move assign\n    ~Packed() = default;                          // Destruct\n\n    bool operator==(const Packed&amp; other) const;   // Equality\n};\n</code></pre>"},{"location":"guides/design-principles/#separation-of-concerns","title":"Separation of Concerns","text":"<p>Principle: Codecs, containers, and algorithms are orthogonal.</p>"},{"location":"guides/design-principles/#three-independent-dimensions","title":"Three Independent Dimensions","text":"<ol> <li>Codecs: How values are encoded</li> <li>Containers: How collections are stored</li> <li>Algorithms: How data is processed</li> </ol>"},{"location":"guides/design-principles/#composability","title":"Composability","text":"<p>Any codec works with any container:</p> <pre><code>// Same container, different codecs\nPackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; vec1;\nPackedVector&lt;Packed&lt;uint32_t, EliasDelta&gt;&gt; vec2;\nPackedVector&lt;Packed&lt;uint32_t, Fibonacci&gt;&gt; vec3;\n\n// Same codec, different containers\nPackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; vec;\nPackedList&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; list;\nPackedArray&lt;Packed&lt;uint32_t, EliasGamma&gt;, 10&gt; arr;\n</code></pre>"},{"location":"guides/design-principles/#concepts-over-inheritance","title":"Concepts Over Inheritance","text":"<p>Principle: Use compile-time concepts instead of runtime polymorphism.</p>"},{"location":"guides/design-principles/#traditional-oop-approach","title":"Traditional OOP Approach","text":"<pre><code>class Codec {\npublic:\n    virtual void encode(uint32_t value, BitSink&amp; sink) = 0;\n    virtual uint32_t decode(BitSource&amp; source) = 0;\n};\n\nclass EliasGamma : public Codec { /* ... */ };\n</code></pre> <p>Problems:</p> <ul> <li>Virtual dispatch overhead</li> <li>Dynamic allocation required</li> <li>Type erasure loses information</li> </ul>"},{"location":"guides/design-principles/#pfc-approach","title":"PFC Approach","text":"<pre><code>template&lt;typename C, typename T&gt;\nconcept Codec = requires(T value, BitSink&amp; sink, BitSource&amp; source) {\n    { C::encode(value, sink) } -&gt; std::same_as&lt;void&gt;;\n    { C::decode(source) } -&gt; std::same_as&lt;T&gt;;\n};\n\nstruct EliasGamma {\n    template&lt;BitSink S&gt;\n    static void encode(uint32_t value, S&amp; sink) { /* ... */ }\n\n    template&lt;BitSource S&gt;\n    static uint32_t decode(S&amp; source) { /* ... */ }\n};\n</code></pre> <p>Benefits:</p> <ul> <li>Zero runtime overhead</li> <li>Better inlining</li> <li>Compile-time type checking</li> <li>No virtual tables</li> </ul>"},{"location":"guides/design-principles/#generic-programming","title":"Generic Programming","text":"<p>Principle: Algorithms work on any type satisfying requirements.</p>"},{"location":"guides/design-principles/#requirements-as-concepts","title":"Requirements as Concepts","text":"<pre><code>template&lt;typename T&gt;\nconcept PackedValue = requires(T t) {\n    { t.encode() } -&gt; std::convertible_to&lt;std::vector&lt;uint8_t&gt;&gt;;\n    { T::decode(std::declval&lt;std::span&lt;const uint8_t&gt;&gt;()) } -&gt; std::same_as&lt;T&gt;;\n};\n\n// Algorithm works on ANY PackedValue\ntemplate&lt;PackedValue T&gt;\nsize_t compute_size(const std::vector&lt;T&gt;&amp; values) {\n    return std::accumulate(values.begin(), values.end(), 0,\n        [](size_t sum, const T&amp; v) { return sum + v.byte_size(); });\n}\n</code></pre>"},{"location":"guides/design-principles/#value-semantics","title":"Value Semantics","text":"<p>Principle: Objects behave like mathematical values.</p>"},{"location":"guides/design-principles/#implications","title":"Implications","text":"<ol> <li>Copying creates an independent object</li> <li>Equality is based on value, not identity</li> <li>No aliasing concerns</li> <li>Predictable behavior</li> </ol>"},{"location":"guides/design-principles/#example_1","title":"Example","text":"<pre><code>PackedInt a(42);\nPackedInt b = a;      // Independent copy\na = 100;              // Doesn't affect b\nassert(b == 42);      // b retains original value\n</code></pre>"},{"location":"guides/design-principles/#algebraic-types","title":"Algebraic Types","text":"<p>Principle: Types form algebraic structures.</p>"},{"location":"guides/design-principles/#product-types-and","title":"Product Types (AND)","text":"<p>Combination of values:</p> <pre><code>// Tuple: A \u00d7 B \u00d7 C\nPackedProduct&lt;PackedInt, PackedString, PackedFloat&gt;\n</code></pre>"},{"location":"guides/design-principles/#sum-types-or","title":"Sum Types (OR)","text":"<p>Exclusive choice:</p> <pre><code>// Variant: A | B | C\nPackedVariant&lt;PackedInt, PackedString, PackedFloat&gt;\n</code></pre>"},{"location":"guides/design-principles/#laws","title":"Laws","text":"<p>Product and sum types obey algebraic laws:</p> <pre><code>A \u00d7 1 \u2245 A           (unit)\nA \u00d7 B \u2245 B \u00d7 A       (commutativity)\n(A \u00d7 B) \u00d7 C \u2245 A \u00d7 (B \u00d7 C)  (associativity)\n\nA + 0 \u2245 A           (identity)\nA + B \u2245 B + A       (commutativity)\n(A + B) + C \u2245 A + (B + C)  (associativity)\n</code></pre>"},{"location":"guides/design-principles/#proxy-iterators","title":"Proxy Iterators","text":"<p>Principle: Decode on access, never store decoded values.</p>"},{"location":"guides/design-principles/#why-proxies","title":"Why Proxies?","text":"<p>Storing decoded values violates the zero-copy invariant:</p> <pre><code>// BAD: Stores decoded values\nstd::vector&lt;uint32_t&gt; decoded_values;\n\n// GOOD: Decodes on access\nPackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; packed_values;\n</code></pre>"},{"location":"guides/design-principles/#implementation_2","title":"Implementation","text":"<pre><code>template&lt;typename T, typename Codec&gt;\nclass PackedIterator {\n    const uint8_t* data_;\n    size_t bit_offset_;\n\npublic:\n    class Reference {\n        const uint8_t* data_;\n        size_t bit_offset_;\n\n    public:\n        operator T() const {\n            BitReader reader(data_, bit_offset_);\n            return Codec::decode(reader);  // Decode on conversion\n        }\n    };\n\n    Reference operator*() const {\n        return Reference{data_, bit_offset_};\n    }\n};\n</code></pre>"},{"location":"guides/design-principles/#correctness-over-performance","title":"Correctness Over Performance","text":"<p>Principle: Correctness first, then optimize.</p>"},{"location":"guides/design-principles/#testing-strategy","title":"Testing Strategy","text":"<ol> <li>Property-based testing: Verify algebraic laws</li> <li>Round-trip testing: encode(decode(x)) == x</li> <li>Edge cases: Boundaries, empty, maximum values</li> <li>Fuzzing: Random inputs</li> </ol>"},{"location":"guides/design-principles/#example-property","title":"Example Property","text":"<pre><code>TEST_CASE(\"Codec round-trip\") {\n    for (uint32_t value = 0; value &lt; 10000; ++value) {\n        uint8_t buffer[64];\n        BitWriter writer(buffer);\n        EliasGamma::encode(value, writer);\n        writer.align();\n\n        BitReader reader(buffer);\n        auto decoded = EliasGamma::decode(reader);\n\n        REQUIRE(decoded == value);\n    }\n}\n</code></pre>"},{"location":"guides/design-principles/#extensibility","title":"Extensibility","text":"<p>Principle: Make extension easy, modification unnecessary.</p>"},{"location":"guides/design-principles/#openclosed-principle","title":"Open/Closed Principle","text":"<p>The library is:</p> <ul> <li>Open for extension: Add new codecs, types, algorithms</li> <li>Closed for modification: Core doesn't need changes</li> </ul>"},{"location":"guides/design-principles/#example-custom-codec","title":"Example: Custom Codec","text":"<pre><code>struct MyCustomCodec {\n    static constexpr bool is_fixed_size() { return false; }\n    static constexpr size_t max_encoded_bits() { return 64; }\n\n    template&lt;BitSink S&gt;\n    static void encode(uint64_t value, S&amp; sink) {\n        // Your encoding logic\n    }\n\n    template&lt;BitSource S&gt;\n    static uint64_t decode(S&amp; source) {\n        // Your decoding logic\n    }\n};\n\n// Immediately works with all PFC infrastructure\nPackedVector&lt;Packed&lt;uint64_t, MyCustomCodec&gt;&gt; vec;\nauto compressed = compress&lt;MyCustomCodec&gt;(data);\n</code></pre>"},{"location":"guides/design-principles/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"guides/design-principles/#time-complexity","title":"Time Complexity","text":"<ul> <li>Encoding: O(log n) for universal codes, O(1) for fixed-width</li> <li>Decoding: Same as encoding</li> <li>Container access: O(n) worst case (sequential scan)</li> <li>Iteration: O(n) for sequential, O(1) per element</li> </ul>"},{"location":"guides/design-principles/#space-complexity","title":"Space Complexity","text":"<ul> <li>Universal codes: O(log n) bits per value</li> <li>Fixed-width: O(1) bits per value (constant)</li> <li>Containers: O(n) compressed bits, no overhead</li> </ul>"},{"location":"guides/design-principles/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>PFC is grounded in information theory and coding theory:</p>"},{"location":"guides/design-principles/#kraft-mcmillan-inequality","title":"Kraft-McMillan Inequality","text":"<p>For prefix-free codes:</p> <pre><code>\u2211 2^(-li) \u2264 1\n</code></pre> <p>Where li is the length of the i-th codeword.</p>"},{"location":"guides/design-principles/#universal-codes","title":"Universal Codes","text":"<p>Elias codes achieve asymptotically optimal encoding for positive integers:</p> <pre><code>Elias Gamma:  \u2308log\u2082(n)\u2309 + 2\u230alog\u2082(n)\u230b + 1 bits\nElias Delta:  \u2308log\u2082(n)\u2309 + 2\u230alog\u2082(log\u2082(n))\u230b + 1 bits\nElias Omega:  O(log n + log log n + log log log n + ...)\n</code></pre>"},{"location":"guides/design-principles/#lessons-from-stl","title":"Lessons from STL","text":"<p>PFC adopts STL design patterns:</p> <ol> <li>Iterators: Separate algorithms from containers</li> <li>Value semantics: Predictable, composable</li> <li>Generic algorithms: Work on ranges, not specific types</li> <li>Concepts: Express requirements precisely</li> <li>No ownership: Containers own, algorithms borrow</li> </ol>"},{"location":"guides/design-principles/#influences","title":"Influences","text":"<ul> <li>Alex Stepanov: Generic programming, STL design</li> <li>Bartosz Milewski: Category theory, algebraic types</li> <li>Peter Elias: Universal codes, information theory</li> <li>Haskell/ML: Algebraic data types, pattern matching</li> <li>Rust: Ownership, sum types, Result</li> </ul>"},{"location":"guides/design-principles/#further-reading","title":"Further Reading","text":"<ul> <li>Stepanov &amp; McJones: \"Elements of Programming\"</li> <li>Elias: \"Universal Codeword Sets and Representations of the Integers\"</li> <li>Knuth: \"The Art of Computer Programming, Vol 1\"</li> <li>MacKay: \"Information Theory, Inference, and Learning Algorithms\"</li> </ul>"},{"location":"guides/error-handling/","title":"Error Handling Guide","text":"<p>Best practices for robust error handling with PFC.</p>"},{"location":"guides/error-handling/#use-result-types","title":"Use Result Types","text":"<p>Prefer Result over exceptions for expected errors:</p> <pre><code>using Result = PackedResult&lt;Packed&lt;int, EliasGamma&gt;, PackedString&gt;;\n\nResult parse_integer(const std::string&amp; s) {\n    try {\n        return Result::ok(std::stoi(s));\n    } catch (...) {\n        return Result::err(\"Invalid integer format\");\n    }\n}\n\n// Caller handles error explicitly\nauto result = parse_integer(input);\nif (result.is_ok()) {\n    process(result.unwrap());\n} else {\n    log_error(result.unwrap_err());\n}\n</code></pre>"},{"location":"guides/error-handling/#chain-operations","title":"Chain Operations","text":"<p>Use monadic operations for error propagation:</p> <pre><code>auto result = parse_integer(\"42\")\n    .map([](int x) { return x * 2; })\n    .and_then([](int x) { return validate_range(x, 0, 100); })\n    .map([](int x) { return format_output(x); });\n</code></pre>"},{"location":"guides/error-handling/#pattern-matching","title":"Pattern Matching","text":"<p>Use visit for exhaustive handling:</p> <pre><code>result.visit(overloaded{\n    [](const auto&amp; value) {\n        std::cout &lt;&lt; \"Success: \" &lt;&lt; value &lt;&lt; \"\\n\";\n    },\n    [](const std::string&amp; error) {\n        std::cerr &lt;&lt; \"Error: \" &lt;&lt; error &lt;&lt; \"\\n\";\n    }\n});\n</code></pre>"},{"location":"guides/error-handling/#validation","title":"Validation","text":"<p>Validate inputs early:</p> <pre><code>Result create_user(const std::string&amp; name, int age) {\n    if (name.empty()) {\n        return Result::err(\"Name cannot be empty\");\n    }\n    if (age &lt; 0 || age &gt; 150) {\n        return Result::err(\"Invalid age\");\n    }\n    return Result::ok(User{name, age});\n}\n</code></pre> <p>See Error Handling API and Algebraic Types.</p>"},{"location":"guides/installation/","title":"Installation","text":"<p>PFC is a header-only C++20 library, making installation straightforward. You have several options for integrating it into your project.</p>"},{"location":"guides/installation/#requirements","title":"Requirements","text":"<ul> <li>C++20 compliant compiler:<ul> <li>GCC 10 or later</li> <li>Clang 12 or later</li> <li>MSVC 2019 (16.11) or later</li> </ul> </li> <li>CMake 3.15+ (optional, for building tests and examples)</li> </ul>"},{"location":"guides/installation/#option-1-header-only-include","title":"Option 1: Header-Only Include","text":"<p>The simplest way to use PFC is to copy the headers directly into your project:</p> <pre><code># Clone the repository\ngit clone https://github.com/spinozarabel/pfc.git\n\n# Copy headers to your project\ncp -r pfc/include/pfc /path/to/your/project/include/\n</code></pre> <p>Then include in your code:</p> <pre><code>#include \"pfc/pfc.hpp\"\n</code></pre>"},{"location":"guides/installation/#option-2-cmake-integration","title":"Option 2: CMake Integration","text":""},{"location":"guides/installation/#as-a-subdirectory","title":"As a Subdirectory","text":"<p>Add PFC as a subdirectory in your CMake project:</p> <pre><code># In your CMakeLists.txt\nadd_subdirectory(external/pfc)\n\nadd_executable(your_app main.cpp)\ntarget_link_libraries(your_app PRIVATE pfc)\n</code></pre>"},{"location":"guides/installation/#with-cmake-install","title":"With CMake Install","text":"<p>Install PFC system-wide:</p> <pre><code>cd pfc\nmkdir build &amp;&amp; cd build\ncmake ..\ncmake --install . --prefix /usr/local\n</code></pre> <p>Then use in your project:</p> <pre><code>find_package(pfc REQUIRED)\n\nadd_executable(your_app main.cpp)\ntarget_link_libraries(your_app PRIVATE pfc::pfc)\n</code></pre>"},{"location":"guides/installation/#option-3-git-submodule","title":"Option 3: Git Submodule","text":"<p>Add PFC as a git submodule:</p> <pre><code>cd your_project\ngit submodule add https://github.com/spinozarabel/pfc.git external/pfc\ngit submodule update --init --recursive\n</code></pre>"},{"location":"guides/installation/#building-tests-and-examples","title":"Building Tests and Examples","text":"<p>To verify the installation and explore examples:</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_CXX_STANDARD=20\ncmake --build . -j4\n\n# Run all tests\nctest --output-on-failure\n\n# Or run individual test suites\n./pfc_tests           # Core functionality\n./test_advanced       # Advanced features\n./test_production     # Production features (Huffman, LZ77, etc.)\n./test_crc            # CRC checksums\n./test_stream_arithmetic  # Stream I/O and arithmetic coding\n\n# Run examples\n./tutorial            # Basic tutorial\n./advanced_demo       # Advanced features\n</code></pre>"},{"location":"guides/installation/#building-with-optional-examples","title":"Building with Optional Examples","text":"<pre><code>cmake .. -DBUILD_MISC_EXAMPLES=ON\ncmake --build .\n\n./simple_test\n./examine_bytes\n</code></pre>"},{"location":"guides/installation/#compiler-configuration","title":"Compiler Configuration","text":"<p>Ensure C++20 is enabled in your compiler:</p>"},{"location":"guides/installation/#gccclang","title":"GCC/Clang","text":"<pre><code>g++ -std=c++20 your_code.cpp -I/path/to/pfc/include\nclang++ -std=c++20 your_code.cpp -I/path/to/pfc/include\n</code></pre>"},{"location":"guides/installation/#msvc","title":"MSVC","text":"<pre><code>cl /std:c++20 /I\\path\\to\\pfc\\include your_code.cpp\n</code></pre>"},{"location":"guides/installation/#cmake","title":"CMake","text":"<pre><code>set(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n</code></pre>"},{"location":"guides/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>PFC has no required dependencies, but can leverage optional libraries for enhanced functionality:</p> <ul> <li>Intel TBB: Enables parallel algorithm execution<ul> <li>Install: <code>apt install libtbb-dev</code> (Ubuntu/Debian)</li> <li>Or: <code>brew install tbb</code> (macOS)</li> <li>CMake will automatically detect and use if available</li> </ul> </li> </ul>"},{"location":"guides/installation/#verification","title":"Verification","text":"<p>Create a simple test file to verify installation:</p> <pre><code>// test_pfc.cpp\n#include &lt;pfc/pfc.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace pfc;\n\n    // Test basic compression\n    std::vector&lt;uint32_t&gt; data = {1, 2, 3, 5, 8, 13};\n    auto compressed = compress&lt;EliasGamma&gt;(data);\n    auto decompressed = decompress&lt;EliasGamma, uint32_t&gt;(compressed);\n\n    if (data == decompressed) {\n        std::cout &lt;&lt; \"PFC is working correctly!\\n\";\n        std::cout &lt;&lt; \"Compressed \" &lt;&lt; data.size() * sizeof(uint32_t)\n                  &lt;&lt; \" bytes to \" &lt;&lt; compressed.size() &lt;&lt; \" bytes\\n\";\n        return 0;\n    } else {\n        std::cerr &lt;&lt; \"Error: Data mismatch\\n\";\n        return 1;\n    }\n}\n</code></pre> <p>Compile and run:</p> <pre><code>g++ -std=c++20 test_pfc.cpp -I/path/to/pfc/include -o test_pfc\n./test_pfc\n</code></pre> <p>Expected output: <pre><code>PFC is working correctly!\nCompressed 24 bytes to 7 bytes\n</code></pre></p>"},{"location":"guides/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/installation/#compiler-errors","title":"Compiler Errors","text":"<p>If you see errors about missing C++20 features:</p> <ol> <li>Verify your compiler version supports C++20</li> <li>Ensure <code>-std=c++20</code> or equivalent is set</li> <li>Check that C++20 concepts are supported</li> </ol>"},{"location":"guides/installation/#cmake-issues","title":"CMake Issues","text":"<p>If CMake can't find the package:</p> <pre><code># Specify the installation prefix\ncmake .. -DCMAKE_PREFIX_PATH=/path/to/pfc/install\n</code></pre>"},{"location":"guides/installation/#include-path-problems","title":"Include Path Problems","text":"<p>Make sure the include path points to the directory containing the <code>pfc</code> folder:</p> <pre><code>project/\n  include/\n    pfc/          &lt;- Point here\n      pfc.hpp\n      core.hpp\n      ...\n</code></pre>"},{"location":"guides/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide: Learn the basics</li> <li>API Reference: Explore available components</li> <li>Examples: See real usage patterns</li> </ul>"},{"location":"guides/performance/","title":"Performance Optimization","text":"<p>Guidelines for getting the best performance from PFC.</p>"},{"location":"guides/performance/#choose-the-right-codec","title":"Choose the Right Codec","text":"<p>Different codecs have different performance characteristics:</p> <ul> <li>Unary: Fastest encoding/decoding, worst compression</li> <li>Fixed-width: Predictable, no branching</li> <li>Elias codes: Good balance of speed and compression</li> <li>Huffman/LZ77: Best compression, slower</li> </ul>"},{"location":"guides/performance/#batch-operations","title":"Batch Operations","text":"<p>Process multiple values together:</p> <pre><code>// Slower: Individual operations\nfor (auto value : values) {\n    packed_vec.push_back(value);\n}\n\n// Faster: Batch insert\npacked_vec.reserve(values.size());\nstd::copy(values.begin(), values.end(),\n          std::back_inserter(packed_vec));\n</code></pre>"},{"location":"guides/performance/#use-parallel-algorithms","title":"Use Parallel Algorithms","text":"<p>With TBB:</p> <pre><code>#include &lt;execution&gt;\n\npacked_transform(std::execution::par_unseq,\n                data.begin(), data.end(),\n                output.begin(),\n                expensive_function);\n</code></pre>"},{"location":"guides/performance/#profile-first","title":"Profile First","text":"<p>Use profiling tools to find bottlenecks:</p> <pre><code>perf record ./your_app\nperf report\n</code></pre> <p>Common hotspots: - Bit I/O operations - Decode-on-access in tight loops - Unnecessary copies</p>"},{"location":"guides/performance/#memory-layout","title":"Memory Layout","text":"<p>Consider alignment and cache behavior:</p> <pre><code>// Good: Sequential access\nfor (size_t i = 0; i &lt; vec.size(); ++i) {\n    process(vec[i]);\n}\n\n// Bad: Random access in packed data\nfor (size_t i : random_indices) {\n    process(vec[i]);  // O(n) worst case\n}\n</code></pre> <p>See Design Principles for performance characteristics.</p>"},{"location":"guides/quick-start/","title":"Quick Start Guide","text":"<p>This guide will get you up and running with PFC in minutes. We'll cover the essential concepts and common usage patterns.</p>"},{"location":"guides/quick-start/#basic-compression","title":"Basic Compression","text":"<p>The simplest way to use PFC is with the high-level compression API:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n#include &lt;vector&gt;\n\nusing namespace pfc;\n\nint main() {\n    // Create some data\n    std::vector&lt;uint32_t&gt; data = {1, 2, 3, 5, 8, 13, 21, 34};\n\n    // Compress with Elias Gamma coding (default)\n    auto compressed = compress(data);\n\n    // Decompress\n    auto decompressed = decompress&lt;uint32_t&gt;(compressed);\n\n    // Verify\n    assert(data == decompressed);\n}\n</code></pre>"},{"location":"guides/quick-start/#understanding-codecs","title":"Understanding Codecs","text":"<p>Codecs transform values to and from bit representations. PFC provides many codecs for different data distributions:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Small positive integers (1-1000)\nauto compressed_gamma = compress&lt;EliasGamma&gt;(data);\n\n// Mix of small and large values\nauto compressed_delta = compress&lt;EliasDelta&gt;(data);\n\n// Geometrically distributed (many small, few large)\nauto compressed_fib = compress&lt;Fibonacci&gt;(data);\n\n// Known range with parameter\nauto compressed_rice = compress&lt;Rice&lt;4&gt;&gt;(data);  // Parameter k=4\n</code></pre>"},{"location":"guides/quick-start/#packed-values","title":"Packed Values","text":"<p>Packed values maintain the zero-copy invariant - they're stored in compressed form:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Define a packed integer type using Elias Gamma\nusing PackedInt = Packed&lt;uint32_t, EliasGamma&gt;;\n\n// Values are stored compressed\nPackedInt value(42);\n\n// Decode on access (zero-copy)\nuint32_t decoded = value.get();\n\n// Can be used in containers\nstd::vector&lt;PackedInt&gt; values;\nvalues.push_back(PackedInt(10));\nvalues.push_back(PackedInt(20));\n</code></pre>"},{"location":"guides/quick-start/#packed-containers","title":"Packed Containers","text":"<p>For dynamic collections, use PackedVector:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Create a packed vector\nPackedVector&lt;Packed&lt;uint32_t, EliasGamma&gt;&gt; vec;\n\n// Add elements\nvec.push_back(1);\nvec.push_back(2);\nvec.push_back(3);\n\n// Access elements (decoded on demand)\nfor (const auto&amp; value : vec) {\n    std::cout &lt;&lt; value &lt;&lt; \"\\n\";\n}\n\n// Works with algorithms\nauto sum = std::accumulate(vec.begin(), vec.end(), 0u);\n</code></pre>"},{"location":"guides/quick-start/#algebraic-types","title":"Algebraic Types","text":"<p>PFC supports rich type composition:</p>"},{"location":"guides/quick-start/#optional-values","title":"Optional Values","text":"<pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Define an optional packed integer\nusing OptionalInt = PackedOptional&lt;Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;&gt;;\n\nOptionalInt some_value(42);\nOptionalInt none_value(std::nullopt);\n\n// Check and access\nif (some_value) {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; *some_value &lt;&lt; \"\\n\";\n}\n\n// Pattern matching with visit\nsome_value.visit(overloaded{\n    [](const auto&amp; val) { std::cout &lt;&lt; \"Some: \" &lt;&lt; val &lt;&lt; \"\\n\"; },\n    []() { std::cout &lt;&lt; \"None\\n\"; }\n});\n</code></pre>"},{"location":"guides/quick-start/#either-type-tagged-union","title":"Either Type (Tagged Union)","text":"<pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Either holds one of two types\nusing IntOrString = PackedEither&lt;\n    Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;,\n    PackedString\n&gt;;\n\nIntOrString left = make_left&lt;IntOrString&gt;(42);\nIntOrString right = make_right&lt;IntOrString&gt;(\"hello\");\n\n// Pattern matching\nleft.visit(overloaded{\n    [](int i) { std::cout &lt;&lt; \"Int: \" &lt;&lt; i &lt;&lt; \"\\n\"; },\n    [](const std::string&amp; s) { std::cout &lt;&lt; \"String: \" &lt;&lt; s &lt;&lt; \"\\n\"; }\n});\n</code></pre>"},{"location":"guides/quick-start/#result-type-error-handling","title":"Result Type (Error Handling)","text":"<pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Result type for operations that can fail\nusing Result = PackedResult&lt;\n    Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;,  // Success type\n    PackedString                       // Error type\n&gt;;\n\nResult parse_int(const std::string&amp; s) {\n    try {\n        return make_ok&lt;Result&gt;(std::stoi(s));\n    } catch (...) {\n        return make_err&lt;Result&gt;(\"Invalid integer\");\n    }\n}\n\n// Check result\nauto result = parse_int(\"42\");\nif (result.is_ok()) {\n    std::cout &lt;&lt; \"Parsed: \" &lt;&lt; result.unwrap() &lt;&lt; \"\\n\";\n} else {\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; result.unwrap_err() &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"guides/quick-start/#numeric-types","title":"Numeric Types","text":""},{"location":"guides/quick-start/#floating-point","title":"Floating Point","text":"<pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Different precisions\nusing Float16 = FloatingPoint&lt;11, 5&gt;;  // Half precision\nusing Float32 = FloatingPoint&lt;24, 8&gt;;  // Single precision\nusing Float64 = FloatingPoint&lt;53, 11&gt;; // Double precision\n\nPackedVector&lt;Packed&lt;double, Float16&gt;&gt; compressed_floats;\ncompressed_floats.push_back(3.14159);\ncompressed_floats.push_back(2.71828);\n</code></pre>"},{"location":"guides/quick-start/#rationals","title":"Rationals","text":"<pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Exact rational representation\nPackedRational pi_approx(22, 7);  // 22/7\nPackedRational euler_approx(271828, 100000);  // 2.71828\n\ndouble as_double = pi_approx.to_double();\n</code></pre>"},{"location":"guides/quick-start/#working-with-bit-io","title":"Working with Bit I/O","text":"<p>For low-level control, use BitWriter and BitReader:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n\nusing namespace pfc;\n\n// Writing\nuint8_t buffer[64] = {};\nBitWriter writer(buffer, sizeof(buffer));\n\n// Encode values\nEliasGamma::encode(42, writer);\nEliasGamma::encode(100, writer);\nwriter.align();  // Align to byte boundary\n\n// Reading\nBitReader reader(buffer, sizeof(buffer));\nauto value1 = EliasGamma::decode(reader);\nauto value2 = EliasGamma::decode(reader);\n\nassert(value1 == 42 &amp;&amp; value2 == 100);\n</code></pre>"},{"location":"guides/quick-start/#stl-integration","title":"STL Integration","text":"<p>PFC containers work seamlessly with STL algorithms:</p> <pre><code>#include &lt;pfc/pfc.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace pfc;\n\nPackedVector&lt;Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;&gt; vec = {5, 2, 8, 1, 9};\n\n// Sorting\nstd::sort(vec.begin(), vec.end());\n\n// Finding\nauto it = std::find(vec.begin(), vec.end(), 8);\n\n// Accumulation\nint sum = std::accumulate(vec.begin(), vec.end(), 0);\n\n// Transformation\nPackedVector&lt;Packed&lt;int, Signed&lt;EliasGamma&gt;&gt;&gt; squared;\nstd::transform(vec.begin(), vec.end(),\n               std::back_inserter(squared),\n               [](int x) { return x * x; });\n</code></pre>"},{"location":"guides/quick-start/#choosing-the-right-codec","title":"Choosing the Right Codec","text":"<p>Different codecs excel with different data distributions:</p> Codec Best For Example Use Case Unary Very small values (1-10) Boolean-heavy data Elias Gamma Small positive integers Counts, small IDs Elias Delta Medium values General purpose Elias Omega Mixed small/large Variable-size data Fibonacci Geometric distribution Network packet sizes Rice/Golomb Known distribution parameter Audio/image residuals Fixed Width Uniform distribution Random data, hashes"},{"location":"guides/quick-start/#performance-tips","title":"Performance Tips","text":"<ol> <li>Choose the right codec for your data distribution</li> <li>Batch operations when possible to amortize overhead</li> <li>Use packed containers instead of std::vector&gt; <li>Profile first - zero-copy doesn't mean zero-cost for small data</li> <li>Consider alignment - align bit streams for better cache usage</li>"},{"location":"guides/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/quick-start/#configuration-storage","title":"Configuration Storage","text":"<pre><code>struct Config {\n    uint32_t version;\n    uint32_t feature_flags;\n    std::string name;\n};\n\n// Serialize\nPackedProduct&lt;\n    Packed&lt;uint32_t, EliasGamma&gt;,\n    Packed&lt;uint32_t, FixedWidth&lt;32&gt;&gt;,\n    PackedString\n&gt; packed_config(42, 0xFF00, \"MyApp\");\n\n// Save to file\nstd::ofstream file(\"config.dat\", std::ios::binary);\nfile.write(packed_config.data(), packed_config.byte_size());\n</code></pre>"},{"location":"guides/quick-start/#network-protocol","title":"Network Protocol","text":"<pre><code>// Define message types\nusing Request = PackedVariant&lt;\n    PackedString,                      // GetRequest\n    Packed&lt;uint32_t, EliasGamma&gt;       // SetRequest\n&gt;;\n\nusing Response = PackedResult&lt;\n    PackedString,                      // Success\n    Packed&lt;uint32_t, FixedWidth&lt;8&gt;&gt;    // Error code\n&gt;;\n\n// Send request\nRequest req = make_variant&lt;0, Request&gt;(\"key\");\nsend_over_network(req.data(), req.byte_size());\n\n// Receive response\nResponse resp = receive_response();\n</code></pre>"},{"location":"guides/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference: Detailed documentation</li> <li>Examples: More comprehensive examples</li> <li>Custom Codecs: Create your own encodings</li> <li>Design Principles: Understand the philosophy</li> </ul>"}]}